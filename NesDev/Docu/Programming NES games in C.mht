From: <Сохранено Windows Internet Explorer 8>
Subject: Programming NES games in C
Date: Mon, 2 Jun 2014 16:35:28 +0300
MIME-Version: 1.0
Content-Type: text/html;
	charset="windows-1251"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://shiru.untergrund.net/articles/programming_nes_games_in_c.htm
X-MimeOLE: Produced By Microsoft MimeOLE V6.00.3790.4862

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>Programming NES games in C</TITLE>
<META content=3D"text/html; charset=3Dwindows-1251" =
http-equiv=3DContent-Type>
<STYLE>BODY {
	TEXT-ALIGN: justify; MARGIN: 32px; FONT-FAMILY: Arial,sans-serif; =
BACKGROUND: #ffffff; COLOR: #000000; FONT-SIZE: 14px
}
BLOCKQUOTE {
	PADDING-BOTTOM: 10px; MARGIN: 0px; PADDING-LEFT: 10px; PADDING-RIGHT: =
10px; PADDING-TOP: 10px
}
H1 {
	FONT-FAMILY: Arial,sans-serif; COLOR: #000000; FONT-SIZE: 20px
}
A:hover {
	COLOR: #ff0000
}
A {
	TEXT-DECORATION: none
}
</STYLE>

<META name=3DGENERATOR content=3D"MSHTML 8.00.6001.23216"></HEAD>
<BODY>
<H1>Programming NES games in C</H1>by Shiru 01'12 mailto:shiru at mail =
dot ru=20
<BR><BR><BR><BR><B>Introduction</B> <BR><BR>This article is aimed to the =
people=20
who would like to start NES software development, but aren't yet ready =
to get=20
into programming large projects in 6502 assembly, and seeking for an =
easier,=20
high level alternative. It covers many topics related to programming NES =
games=20
in C using <A href=3D"http://www.cc65.org/" target=3D_blank>CC65 =
compiler</A>, with=20
<A href=3D"http://shiru.untergrund.net/files/nes/chase.zip">a specially =
developed=20
simple game</A> provided as an example. <BR><BR>The goal of developing =
the=20
example game was to provide a real, complete project with very simple =
and short=20
code that is easy to figure out. My previous projects were rather large, =
and=20
lacked comments almost completely, so they aren't too good to be used as =
an=20
example. The example game also include latest version of my low level =
code that=20
was developed and used in my previous NES projects. <BR><BR>If the =
example game=20
code is still too large and complex to figure out, check <A=20
href=3D"http://shiru.untergrund.net/files/src/cc65_nes_examples.zip">thes=
e small=20
example programs</A> that also use the same low level code and =
demonstrate how=20
to do certain simple things such as outputting text or sprites.=20
<BR><BR><BR><BR><B>What you need to know</B> <BR><BR>To make a NES game =
you need=20
to have a lot of prior knowledge. It is impossible to give even brief=20
explaination of everything that is involved in a single article, so =
check this=20
list, if you don't know something, you'll probably need to learn it =
somewhere.=20
There are a lot of books and articles about these things around. You can =
find=20
practically all the NES-specific information in the <A =
href=3D"http://nesdev.com/"=20
target=3D_blank>NesDev</A> wiki and forums. <BR><BR>
<UL>
  <LI>Good knowledge of C language=20
  <BLOCKQUOTE>
    <LI>Bitwise operations and bit shifts=20
    <LI>Fixed point calculations=20
    <LI>Pointers </LI></BLOCKQUOTE>
  <LI>Basic knowledge of 6502 CPU=20
  <BLOCKQUOTE>
    <LI>Registers=20
    <LI>Zero page=20
    <LI>Stack page </LI></BLOCKQUOTE>
  <LI>Basic knowledge of NES hardware, especially PPU=20
  <BLOCKQUOTE>
    <LI>CHR ROM=20
    <LI>Nametables=20
    <LI>Palettes=20
    <LI>Sprites=20
    <LI>VBlank time and VRAM access=20
    <LI>CPU and PPU memory maps </LI></BLOCKQUOTE>
  <LI>Windows command line and batch files </LI></UL><BR><BR><B>Pros and =
cons</B>=20
<BR><BR>Programming for NES in C has two major drawbacks comparing to=20
programming in assembly. First, compiled code is always slower than =
handwritten=20
assembly code. Second, it is always way larger. The size is actually =
could be=20
even more important than the speed. On the other hand, smaller code is =
usually=20
faster as well. <BR><BR>There is an advantage that comes in exchange for =
these=20
drawbacks - you can develop software in C much faster, because you need =
to=20
write, debug, and mantain few times less code, and the code is much more =

readable. Also, you get some abstraction from the hardware, so you =
probably will=20
be capable to make a simple NES program even without knowledge of 6502 =
assembly,=20
although it certainly could help. <BR><BR>Here is a practical example =
that could=20
convince you that C is a real timesaver: hand-written assembly code to =
retrieve=20
a value from a 32x32 map array using two 8-bit coordinates (mx,my), and =
its C=20
equivalent: <BR><BR>
<TABLE width=3D"90%" align=3Dcenter>
  <TBODY>
  <TR>
    <TD vAlign=3Dtop width=3D"50%" align=3Dleft><PRE>; assembly version

 lda my		;multiply my by 32
 sta ptr_h	;through shifting
 ldy #0		;a 16-bit var (ptr_h,ptr_l)
 sty ptr_l	;to the right for three times
dup 3
 lsr ptr_h	;shift
 ror ptr_l
edup
 lda ptr_l	;add mx as 16-bit value
 clc
 adc mx
 bcc @1
 inc ptr_h
@1:
 clc
 adc #&lt;map	;add map offset
 sta ptr_l
 lda ptr_h
 adc #&gt;map
 sta ptr_h
 lda [ptr_l],y	;read the value
</PRE></TD>
    <TD vAlign=3Dtop width=3D"50%" align=3Dleft><PRE>// C version

n=3Dmap[(my&lt;&lt;5)+mx];
</PRE></TD></TR></TBODY></TABLE><BR><BR><BR><B>Optimization</B> =
<BR><BR>Due to=20
very limited NES resources, such as CPU speed, RAM and ROM size, =
writting a=20
proper, clean C code isn't very effective. To make it faster and shorter =
you=20
have to optimize it through doing things that otherwise aren't =
considered=20
acceptable. They are disable some of C advantages, making the code more =
low=20
level and less structured, but even with these limitations it remains =
very high=20
level comparing to assembler. <BR><BR>There are suggestions that will =
make your=20
code more effective, but certainly less readable: <BR><BR>
<LI>Avoid local variables as much as possible, make them static at least =

<LI>Avoid passing parameters to functions=20
<LI>Avoid to use functions that only used once=20
<LI>Use __fastcall__ calling convention=20
<LI>Arrays of structs are slow, separate arrays are faster=20
<LI>Fastest type is unsigned char, use it as much as possible. Don't =
forget that=20
in CC65 int is 16 bit wide=20
<LI>Signed types are slower=20
<LI>You can put some variables into zero page using a pragma (see =
below), it=20
makes them faster=20
<LI>Don't forget that you need to declare array of pointers as const =
type* const=20
if you need to put it into ROM=20
<LI>Use preincrements where possible, they are both faster and shorter=20
<LI>Avoid to use multiple and division as much as possible, they are =
very slow.=20
Use bit shifts where possible instead=20
<LI>If you need to process an array of objects, it is better to copy =
data from=20
arrays to separate vars. Use these vars in the code, and then copy new =
data back=20
to the arrays. This could make code significally shorter and faster, =
because=20
access to an array item generates more code than access to a variable=20
<LI>Declaring global variables as static also helps to find unused =
global=20
variables, compiler will report about them <BR><BR>If your program hits =
the CPU=20
limit, and you need to optimize C code as much as possible, you can =
profile it=20
using some debugging NES emulators. For example, there is a version of =
VirtuaNES=20
that can measure time in CPU clocks between two writes into special =
virtual=20
registers $401e and $401f. The emulator displays the time on the screen. =
There=20
is about 30000 CPU clocks in one single frame, so you can have idea how =
much=20
time a code portion takes, and see how your code tweaks affect to the =
execution=20
time. <BR><BR><B>Setup and first compile</B> <BR><BR>Before explaining =
how=20
certain things were done in the example game, it is a good idea to setup =
the=20
tools and compile the game by yourself. <BR><BR>My NES development =
enviroment is=20
very primitive, I don't use IDEs or anything. Just a Notepad++ as code =
editor,=20
CC65 as command line compiler, some bat files for build automation, and =
an=20
emulator for testing. I also use set of tools to create resources, more =
on this=20
later. <BR><BR>Download CC65 and unpack it into a directory, for example =
c:\cc65=20
- so folders like \bin\, \include\, \lib\ etc will be placed into this=20
directory. Unpack the example game source code into the cc65 directory =
too, so=20
it will be in a separate folder. Build script uses relative path, so you =
won't=20
need to do anything else - just run compile.bat. It'll pause after =
compilation,=20
so you could see if there were any errors, and after pressing a key it =
starts=20
the compiled game in an emulator, if you have one that is associated =
with *.nes=20
files. <BR><BR>You can alter build process by editing compile.bat, or =
setup an=20
IDE. You can use a 'run' feature of a code editor, such as F5 button in=20
Notepad++, but you probably would need to edit build script adding =
absolute=20
paths. I can't give detailed explaination of all these possibilities, so =

research and do it on your own. <BR><BR><BR><BR><B>Low level code and=20
configuration</B> <BR><BR>There are few low level code parts in the =
example=20
game. You won't mess with them directly most of the time, but in certain =
cases=20
it could be needed, so it is a good idea to look at these files briefly, =
and get=20
understanding why they are there. These parts are located in *.s, *.lib, =
and=20
*.cfg files. <BR><BR><I>crt0.s</I> - startup code. It inits the =
hardware, libs,=20
etc. There are few settings in the beginning of the file, you may need =
to change=20
them if you need to use different kind of mirroring in your project or =
use a=20
mapper, for example. <BR><BR><I>runtime.lib</I> - C runtime, i.e. some =
important=20
code of basic language functionality, such as math routines. This is a =
custom=20
compile that does not contain any NES specific code. If you need to =
change it=20
for some reason, you'll need to get CC65 source code and have some fun =
compiling=20
it with GNU make. <BR><BR><I>nes.cfg</I> - definiton of the NES memory =
layout.=20
It is configured for NROM128 project, if you need to make NROM256, add =
samples,=20
or add extra RAM support, you'll need to edit this as well. =
<BR><BR><BR>To add=20
some abstraction from the hardware, and make hardware-dependent =
operations=20
faster, there is also my custom low level part that implements some C =
functions.=20
You can freely use it in your projects, or you can use it as an example =
to make=20
your own code, if this one does not have everything that you need. You =
could=20
call it a library, but it is actually provided as assembly source code, =
because=20
NES projects tend to require some minor tweaks, like removing unneeded=20
functionality to save some space. <BR><BR><I>neslib.s</I> - is the =
custom=20
library itself<BR><I>neslib.h</I> - C prototypes for the library's =
functions.=20
There are comments that documents the functions <BR><BR>The custom =
library also=20
includes FamiTone2 audio library code and sound data in a few separate =
files:=20
<BR><BR><I>famitone.s</I> - sound library that plays music and sound=20
effects<BR><I>sounds.s</I> - sound effects data generated by the =
nsf2data=20
tool<BR><I>music.s</I> - music data generated by the text2data tool=20
<BR><BR><BR><BR><B>Game code and resources</B> <BR><BR>Game code itself =
is=20
contained in *.c and *.h files. In case of the example game it is just =
game.c=20
file. <BR><BR>There is a lot of resources as well. They are represented =
in many=20
ways - *.h files (nametables), *.s files (music), *.chr file (graphics). =

Potentially *.h and *.s files could be used for anything, and also =
include=20
different binary formats. Usually these files are automatically =
generated with=20
tools, so don't wonder why there are so many numbers inside without any=20
explainations. <BR><BR>Not much to say about the game code itself - take =
all the=20
information from this article into account and read the comments in the =
code,=20
there are plenty of them. <BR><BR>More important thing to explain is how =
to make=20
all the game resources, because simply being able to write and compile =
some code=20
is not enough to make a game. Another important thing is how to handle =
certain=20
programming related things in general. <BR><BR><BR><BR><B>Graphics</B>=20
<BR><BR>In a NROM game there are two sets of 8x8 graphics pieces, also =
called=20
characters, patterns, or tiles. There are 256 of them in each set. You =
can use=20
one of sets for background graphics, and other set for sprites. =
Alternatively=20
you can put both background and sprites graphics into one set, slightly =
modified=20
copy into other, and switch between the sets to create a rough two-frame =

animation. This is how the animation done in the example game. =
<BR><BR>All the=20
graphics for the example game is created with <A=20
href=3D"ftp://ftp.untergrund.net/users/shiru/nesst.zip">NES Screen =
Tool</A> from=20
scratch, i.e. drawn with its built-in CHR editor. The tool outputs =
graphics as=20
*.chr file, it is tileset.chr in the example game. You can also edit =
palettes=20
and nametables there, they could be saved in different formats or =
copy/pasted as=20
pieces of data directly into the source code. <BR><BR>Large letters and =
numbers=20
were also drawn with NES Screen Tool. They look messy in the tileset =
now, but I=20
didn't drawn them that way. Instead, I used 2x3 tiles areas for every =
symbol, so=20
they had their true shape in the tileset. This lead to many repeating or =
empty=20
tiles, however. To save space the Optimize function of the tool was =
used. To=20
make things easier I first created nametables for Level, Game Over and =
Well Done=20
screens with unoptimized tileset, and also an extra nametable with the =
large=20
numbers. Then I loaded every nametable with unoptimized tileset and used =

Optimize - this rearranged the loaded nametable for optimized version of =
the=20
tileset. This approach saved me from solving a puzzle of creating =
screens from=20
messed pieces of the optimized tileset. <BR><BR>If you need to work with =
more=20
complex, larger graphics that in the example game, NES Screen Tool could =
be not=20
very comfortable. In this case you can use a normal general purpose =
graphics=20
editor to create the graphics following the NES limitations, then =
convert and=20
tweak it with NES Screen Tool. Check the docs provided with the tool for =

details. <BR><BR>I mostly use <A =
href=3D"http://www.humanbalance.net/gale/us/"=20
target=3D_blank>GraphicsGale</A> as general purpose pixel art editor, =
sometimes <A=20
href=3D"http://www.gimp.org/" target=3D_blank>GIMP</A> as well. You can =
use these or=20
any other, just make sure that your graphics editor has some features =
that make=20
this kind of work much easier. The features are: <BR><BR>
<LI>8x8 and 16x16 grids to track how many colors you used in a cell more =
easily=20
and to align the graphics properly=20
<LI>Snap to grid feature, useful when you need to move graphics around =
without=20
losing alignment=20
<LI>Layers are always useful=20
<LI>Indexed palette control, ability to move colors around the palette, =
very=20
useful for preparing the graphics for conversion <BR><BR><B>Large =
sprites</B>=20
<BR><BR>NES graphics hardware is only capable to display small sprites, =
that are=20
either 8x8 or 8x16. My low level library only supports 8x8 mode. To have =
larger=20
sprites you need to construct them from few smaller ones. That's called =
a=20
metasprite. To handle metasprites with my library you have to define =
them as an=20
array of tile numbers, attributes, and offsets from the pivot point. =
<BR><BR>If=20
your metasprites are basically a rectangle consisting of few tiles =
placed on the=20
regular 8x8 grid, you can use NES Screen Tool to generate the =
definitions. You=20
draw metasprite just like you draw a part of nametable, then select the =
part of=20
the nametable with the sprite, and use Nametable/Copy metasprite =
function of the=20
program. It'll place the definition into the clipboard, so you can paste =
it into=20
your source code. It is possible to automatically generate a =
horizontally=20
flipped copy as well - this way you will use only one set of graphics =
for both=20
left and right-faced versions, but two metasprite definitions. In my =
library I=20
considered that flipping a metasprite definition in runtime is not =
acceptable,=20
because it is slow, and these definitions aren't take too much memory.=20
<BR><BR>For complex metasprites that aren't aligned to the regular grid =
you'll=20
have to write the definitions by hand. <BR><BR><BR><BR><B>Levels</B> =
<BR><BR>In=20
all my NES projects that were written in C, including the example game, =
I took a=20
shortcut and used NES Screen Tool as a level editor. It works well for =
simple=20
games, you just draw and save a level as a nametable. For more complex =
games you=20
would need to make a custom editor, or make an export script for a =
general=20
purpose one, such as Tiled. <BR><BR>Please note that in the example game =
map=20
array in the memory is twice smaller compared to the level nametable. =
The levels=20
stored as RLE-packed nametables, unpacked directly into VRAM, then read =
back row=20
by row to construct the map array. Object spawn positions are also =
defined in=20
the nametables, they are removed in the process, and rows written back =
into the=20
the VRAM. It is not very straightforward, but works well enough, and =
ultimately=20
make things simpler - no need for a special map editor that would output =
map in=20
an optimal format, no need to construct nametables from that optimal =
format in=20
the runtime. <BR><BR><BR><BR><B>Sound effects</B> <BR><BR>The sound =
effects are=20
created in <A href=3D"http://famitracker.shoodot.net/">FamiTracker</A> =
for the <A=20
href=3D"ftp://ftp.untergrund.net/users/shiru/src/famitone2.zip">FamiTone2=
</A>=20
requirements. The requirements for sound and music are detailed in the =
FamiTone2=20
docs. In short, the process of sound effects creation is like this: you =
make=20
them in FamiTracker as a multi song file, each effect is a song that =
ends with=20
C00 command. Then you export NSF file and convert it into an assembly =
file: <PRE>nsf2data sounds.nsf -ca65
</PRE>The resulting sounds.s file is placed into the project directory, =
it is=20
always included into the project from crt0.s. If you don't need sound =
effects in=20
your project, you can disable them with a define there. This will =
exclude all=20
related code as well. <BR><BR>There are very few sound effects in the =
example=20
game, so handling priorities is not demonstrated well. There are four =
virtual=20
channels for sound effects, numbered from 0 to 3. Virtual channels are =
mixed=20
with music and each other by the volume (louder parts take priority), =
except for=20
the triangle channel, which is always overlapped with a sound effect =
channel of=20
the higher number. If a new effect is started on a channel while other =
effect=20
plays there, the old effect will be stopped. Thus it is important to =
plan which=20
effect should interrupt each other and which should not, and put them on =

different virtual channels. <BR><BR><BR><BR><B>Music</B> <BR><BR>Music =
is also=20
created in FamiTracker for the FamiTone2 requirements. All the songs are =
made as=20
a multisong file, so they share the same set of instruments. They are =
then=20
exported with FamiTracker built-in text exporter and converted into an =
assembly=20
file: <PRE>text2data music.txt -ca65
</PRE>If FamiTone2 feature set is somehow too limited for you, you can =
hook up=20
the native FamiTracker player instead. Its code is compilable with ca65, =
but it=20
would require quite some work that requires 6502 assembly knowledge, =
especially=20
if you need to have sound effects support. It is also three times larger =
and=20
twice slower, so make a decision judging by how much free memory and CPU =
time=20
you have in a project. <BR><BR><BR><BR><B>PAL and NTSC</B> <BR><BR>One =
important=20
thing that is specific for all the computer systems that use TV as =
display=20
device, including NES, is the difference between NTSC and PAL. Since TV =
frame=20
rate is the main sync source in programs for these systems, and it is =
differs by=20
17% between them (50 or 60 Hz of vertical refresh), it should be handled =

somehow. There are three ways to do this in general. <BR><BR>First and =
probably=20
the most accurate way is to make the program use fixed point =
calculations=20
everywhere, and create two versions of the program - one with constant =
values=20
(such as speed of an object) calculated for NTSC, and other with the =
values=20
calculated for PAL. PAL constants are NTSC*18/15. <BR><BR>Mantaining two =

versions of the same program could be rather inconvient, so the second =
way is to=20
make the program detect which system is used, and use one of two sets of =

constants. This way allows to have just one version of the program, but =
it is=20
still unconvient. Not only you have to make all the calculations in =
fixed point,=20
but now you also don't really have constants, since they are changing =
depending=20
from the system - so you either need to use variables instead, or have =
two=20
versions of some parts of the code. <BR><BR>My library uses third way, =
which is=20
not very accurate, but is free from the disadvantages of the first two =
methods.=20
It detects the system at start up and skips every sixth frame if the =
program=20
runs on an NTSC console. So you only need to tweak your timings for PAL =
once,=20
and they will work the same on NTSC, with a little bit of jerkiness =
added into=20
the movements. It is used in all my NES games, so you can check them out =
to=20
decide whether it is noticeable or not. If you want to use my library, =
but would=20
like to handle the PAL/NTSC problem in some other way, you can disable =
the=20
frameskip through a define in the crt0.s. <BR><BR>In any case my library =
will=20
compensate the speed difference for music, but not for music pitch and =
speed of=20
sound effects. It is a compomise between CPU load and extra ROM size =
that I=20
assumed to be acceptable. You can change these things too, if you want, =
but it=20
would require some changes in low level part, such as adding a second =
note=20
frequency table, and probably a second copy of sound effects data.=20
<BR><BR>Another thing that you have to remember is that the VBlank time =
is much=20
longer in PAL, and that's the only time when access to the VRAM is =
possible with=20
enabled display. This time is used by the library's update system that =
is=20
controlled by vram_set_update and could be used for such things as =
displaying=20
game stats or level scrolling. If you want to make your program work =
properly on=20
both systems, you should debug it in NTSC - if it works there, it is =
guaranteed=20
that it also will work in PAL, but not vice versa. =
<BR><BR><BR><BR><B>RAM=20
usage</B> <BR><BR>One of things that you could always remember while =
desiging=20
NES software is that it has very limited amount of RAM - just 2048 =
bytes.=20
Furthermore, not all of these are available for C programs. <BR><BR>512 =
bytes of=20
the RAM are used by CPU in a special way. It is result of the CPU design =
and=20
can't be changed. First 256 bytes are given to the zero page, a special =
RAM=20
location, with about 48 of these being used by libraries. Next 256 bytes =
are=20
given to the CPU stack. Luckily, code that is generated by C compiler =
barely=20
uses CPU stack - about 32 bytes at max even in large and complex =
programs. This=20
allows to allocate some internal buffers in the remaining stack space. =
My=20
library uses it for sound and music player variables and internal =
palette=20
buffer. <BR><BR>Besides of these, another 256 bytes are used for OAM =
buffer that=20
is sent through DMA into PPU every frame. That's required by the PPU =
design and=20
can't be changed too. <BR><BR>So in the end you are given with just 1280 =
bytes=20
of RAM to store your variables, arrays, buffers and so on. For =
comparsion, one=20
nametable is 1024 bytes large. <BR><BR>To make local variables work =
faster you=20
have to make them static, but this also makes them occupy a RAM location =

constantly. That's why making a set of general purpose global variables =
that are=20
reused everywhere is recommended. Global variables are a little bit =
faster than=20
local static ones as well. <BR><BR>You can get some extra RAM by placing =
some=20
variables into zero page, which has about 200 bytes free. That will also =
make=20
them work faster and make compiled code a bit smaller. Putting common =
set of=20
global variables there is a good idea. You can do it by using these =
pragmas=20
before the variables that should go to zero page: <PRE>#pragma bssseg =
(push,"ZEROPAGE")
#pragma dataseg(push,"ZEROPAGE")
</PRE>If you want to put some subsequent variables back to the normal =
place, you=20
can use these pragmas: <PRE>#pragma bssseg (push,"BSS")
#pragma dataseg(push,"BSS")
</PRE>Please note that for the next release of CC65, which is currently =
only=20
avaialble as a development snapshot, it should be changed to this: =
<PRE>#pragma bss-name (push,"ZEROPAGE")
#pragma data-name(push,"ZEROPAGE")
</PRE>If your project really needs more than ~1500 bytes of RAM, there =
is an=20
option to use extra 8K RAM. This is not an easy decision if you going to =
make a=20
physical release, because that'll require to put an extra RAM chip into =
every=20
cartridge. To make this memory usable by CC65 you have to edit nes.cfg, =
check=20
comments there. <BR><BR><BR><BR><B>ROM size</B> <BR><BR>As the example =
game is=20
very small, it is compiled as NROM128 - one 16K bank of PRG ROM and one =
8K bank=20
of CHR ROM. The number 128 is the PRG ROM size in kilobits (16*8). For =
larger=20
but still mapperless projects you should use NROM256, which is more =
common. It=20
has two 16K PRG ROM banks, so 32K in total for code and data. To change =
the=20
project to this configuration you need to change a define in the crt0.s, =
and=20
edit nes.cfg - check for comments marked as NROM256. <BR><BR>You can =
make even=20
larger projects with mappers as well. However, I can't give you much =
details on=20
this, because I don't have such experience. You can easily control CHR =
banks=20
through a custom function. I don't think the compiler is capable to =
place code=20
across PRG banks and perform bankswitching automatically, though, so =
either your=20
code should completely fit into the fixed bank, and use banks to access =
to the=20
data, or you have to handle bankswitching somehow. You also could put =
music and=20
sound player code and data into a separate bank, this would require =
minor=20
changes in the library code. <BR><BR>As CC65 compiler does not report =
how much=20
ROM space is used in an easily readable form, I made a small tool, <A=20
href=3D"ftp://ftp.untergrund.net/users/shiru/nessp.zip">NES Space =
Checker</A>,=20
that displays it as a simple graph. You may find it handy too. Try to =
use it on=20
the example game, and you'll see that less than quarter of 16K PRG is =
empty.=20
<BR><BR><BR><BR><B>Writing functions in assembly code</B> <BR><BR>If you =
get=20
into a situation when optimizing C code does not give needed speed or =
size no=20
matter what, you have an option is to manually rewrite a piece of code =
into=20
assembly. To do this, you need to know 6502 assembler and figure out RAM =
layout=20
to get some room for your variables. The question that will arise here =
is how to=20
create C interface to an assembly routine. Of course, the answer is =
buried=20
somewhere in the docs and source code, but to save you some time I =
provide=20
explaination here. <BR><BR>First you need a place to put your code. You =
can put=20
them into a separate file, let's say myfuncs.s. To do this you need to =
change=20
the build script (check ca65 calls there and add one for the new file), =
then add=20
myfuncs.o into ld65 parameters before game.o. Generally it is supposed =
that one=20
file contain just one function, but you can put them all into a single =
file as=20
well. You can even not create any new files and simple put your =
functions into=20
neslib.s if you want, just remember that this way all the code in a file =
will be=20
included into the project, even if it is never called. <BR><BR>You also =
need to=20
make a function prototype. Put it into the source code or into a header. =

<BR><BR>Simplest possible function is one that does not take any =
parameters and=20
does not return anything: <PRE>void __fastcall__ func(void);
</PRE>Assembly counterpart will look like this: <PRE> .export _func =
;makes the function available outside of the file

_func:
	... ;your code
	rts
</PRE>Now a function that takes a parameter and returns a parameter as =
well: <PRE>unsigned char __fastcall__ func(unsigned char n);

 .export _func

_func:
	;n is already in the register A
	...
	;put your return value into the register A
	rts
</PRE>For 16-bit vars you should to use X:A pair, with LSB in A and MSB =
in X.=20
<BR><BR>In case of more than one input parameter, things are more =
complex. The=20
__fastcall__ calling convention puts the latest parameter into A or X:A, =
but all=20
the preceding parameters are put on the software stack, which is slow. =
So you=20
generally should avoid to use many parameters when possible. =
<PRE>unsigned int func(unsigned int x,unsigned int y,unsigned char =
n,const unsigned char *ptr);

 .export _func

_func:
	;ptr is in X:A
	jsr popa
	;n is in A
	jsr popax
	;y is in X:A
	jsr popax
	;x is in X:A
	...
	;put your return value into X:A
	rts
</PRE><BR><BR><B>Debugging</B> <BR><BR>My low level part is tested in =
few actual=20
projects and it is confirmed that it works on the real hardware. Using =
it you=20
can reduce chances to make a program that works only in emulators, but =
not on=20
the actual console. However, you still can write something that will not =
work on=20
the hardware. So it is good idea to test your software on the console =
using=20
PowerPak or some other way. Of course, testing in emulators during the=20
development process is much more convinent. Use few emulators to test, a =
good=20
set is Nestopia, Nintendulator, FCEUX and Mednafen - this could reveal =
some=20
problems that aren't visible in the emulator that you use most of the =
time.=20
Testing both in NTSC and PAL is a good idea too, for example in FCEUX =
there are=20
things visible in PAL that are hidden in NTSC. <BR><BR>Sometimes there =
are=20
problems that occur really briefly, or require to perform a very well =
timed=20
actions. For example, a wrong palette is set for one frame, or collision =
check=20
does not work properly with certain coordinates. Many emulators has =
features=20
that could help you a lot with figuring out these things - slow down,=20
frame-by-frame step, and input recording. <BR><BR>When you write =
something that=20
seemingly should work properly, but it doesn't, the real fun begins. The =
problem=20
is that there aren't many comfortable debuggers for C code compiled into =
6502=20
assembly around (yet) - ones that allow to put breakpoints on random C =
lines and=20
see what the variables contain at the moment. The only C level debugger =
is=20
currently available in NESICIDE. Usually you only have an assembly level =

debugger in some emulators, and it is not very helpful with compiled =
code.=20
<BR><BR>One of things that could help a bit to figure out what is wrong =
is=20
outputting pieces of C source code as comments for generated assembly =
code. It=20
is already enabled in the build script of the example game. Compiler =
places code=20
that is generated from game.c into game.s, you can see this file after =
you start=20
compile.bat and before pressing any key. This is also comes handy when =
you want=20
to check out how effective your C code was compiled, and would like to =
try some=20
ideas to make it compile better. <BR><BR>You can use things like =
while(1); as a=20
crude breakpoint, or use sound effects as confirmation that certain part =
of code=20
is reached, etc. <BR><BR>If you need to output a debug value, you can =
put it=20
into an unused RAM location, usually it is end of the zero page, and =
check it=20
with a built-in memory viewer in an emulator. Some emulators also allow =
to watch=20
for an address in more comfortable way. You can use pointers to write =
something=20
into an address in C: <PRE>*(unsigned char*)0x00ff=3D1; //write 1 into =
$00ff, it is the last byte of the zero page
</PRE><BR><BR><B>Alternatives</B> <BR><BR>In this article I only =
explained my=20
own approach to the things. There are alternatives for some tools, code, =
and=20
methods mentioned in the article, so you have choice. I recommend you to =
check=20
<A href=3D"http://kkfos.aspekt.fi/" target=3D_blank>Kalle's Kanister web =
site</A>,=20
specifically KNES, Pornotracker, and MUSE projects. Another very =
promising=20
alternative that is going to be much simpler than the approach explained =
in this=20
article is <A href=3D"http://www.nesicide.com/" =
target=3D_blank>NESICIDE</A>, check=20
it out too. </LI></BODY></HTML>
