ZXDev
=====

ZXDev - это мощная подсистема для кросс-разработки на четырёх языках для компьютера
Sinclair ZX Spectrum. Основана на оптимизирующем компиляторе высокого класса SDCC -
  http://www.z88dk.org/forum/viewtopic.php?id=4178
  https://sourceforge.net/apps/trac/sdcc/wiki/z80%20code%20size ),
компонентной Оберон-среде BlackBox Component Builder, а также на подсистеме Ofront,
которая умеет транслировать Оберон-модули в текст на языке Си.

Также содержит некоторые утилиты и библиотеки для ZX Spectrum (Basic, Laser).

Идеально подходит как для смешанной высокоуровневой и низкоуровневой разработки,
так и для совместного использования в проектах нескольких языков программирования,
а также параллельной разработки для нескольких платформ (с ZX Spectrum включительно).

Цель проекта XDev/ZXDev — получить интегрированную среду разработки для ZX Spectrum
(а впоследствии и для других платформ, с единого исходника, отличаться будут только
низкоуровневые библиотеки) на различных языках программирования. Предпочтение будет
отдаваться модульным языкам, таким как Модула-2, Модула-3, Компонентный Паскаль.

Оберон - самый простой мультипарадигменный ОО-язык, наследник Паскаля и Модулы-2,
квинтэссенция европейской школы информатики и достижение на поприще модульных языков.


Языки разработки: Оберон, Оберон-2, Си, ассемблер процессора Z80.
Хост-платформы: Microsoft Windows 3.1 (+Win32s), Win32, Win64, Linux/Wine.
Целевые платформы: Sinclair ZX Spectrum 48Kb (Z80), Win32 (PE EXE/DLL), Linux x86-32 (SO).

Планируется поддержка других языков (Модула-2, Паскаль, возможно, Компонентный Паскаль)
и кодогенерации для других платформ (UNIX/Linux, J2ME, Android).

Возможности
===========

- Поддержана плоская модель памяти Sinclair ZX Spectrum с 48Kb.
- Реализована эффективная оптимизирующая кодогенерация (средствами SDCC).

Доступные библиотеки
====================

- Libs/Basic.odc - Sinclair ZX Spectrum Basic for Ofront/SDCC
- Libs/Laser.odc - Laser Basic for Ofront/SDCC

Быстрый старт
=============

Скачать: https://github.com/Oleg-N-Cher/BB-XDev/zipball/master
Контроль версий: https://github.com/Oleg-N-Cher/BB-XDev
Официальный форум: http://zx.oberon2.ru/forum/viewforum.php?f=10
Документация: ZXDev/Docu

Файлы .odc - это Oberon DoCument, открываются в программе BlackBox.exe,
можете ассоциировать их с ней.

Tiny HelloWorld
---------------
1. Запустить BlackBox.exe
2. File -> Open -> ZXDev/Mod/TinyHello.odc
3. Компилируем: F11
4. Линкуем: ZXDev/TinyHello.bat

Размер целевого бинарника TinyHello.bin составляет 45 байт.

Если взять пустой модуль:

MODULE HelloWorld; IMPORT B := Basic; PROCEDURE Main* ; END Main; END HelloWorld.

то файл HelloWorld.bin занимает после компиляции 2 байта: #C9#C9 (RET RET).
Оверхед в один байт, что, кажется, не так уж и плохо.

LaserDemo
---------
1. Запустить BlackBox.exe
2. File -> Open -> ZXDev/Mod/LaserDemo.odc
3. Компилим: F11
4. Линкуем: ZXDev/LaserDemo.bat

Если размер бинарника в 11,5 Кб кажется слишком большим, то учтите, что в кодовый блок
включается ВСЯ библиотека Laser, однако есть идея как включать из неё только самые
необходимые фрагменты (Если хотите проделать такую работу, свяжитесь со мной).
Также учтите, что в код включены ВСЕ спрайты из пакета ZXDev/Libs/Laser/SPRITE2B.
Разумеется, здесь тоже можно включить только необходимые, выбросив неиспользуемые.


"Умная" линковка (smart linking)
================================
Текущая стратегия компоновщика: прилинковывать все указанные в командной строке .rel-файлы.
Из указанных библиотек линковать только .rel-файлы, необходимые для разрешения зависимостей.

Пример:

Вы указали компоновщику rel-файлы A и B и библиотеки X и Y.
Внутри библиотеки X имеются модули X1 и X2, внутри Y имеются модули Y1 и Y2.
Предположим, что A содержит функцию f, B содержит функцию g (которая вызывает h),
X1 содержит h (которая вызывает i), и Y2 содержит i.

В этом случае A, B, X1 и Y2 будут прилинкованы к результирующей программе.

На практике это значит, что экономия кода может быть достигнута если при разработке библиотек
они вручную разделены на атомарные сущности (и представляют в итоге набор .rel-файлов,
которые могут быть зависимыми друг от друга и от других библиотек). Для не-библиотек
(и сгенерированных Ofront'ом сишных исходников), из которых порождается один .rel-файл,
поведение линкера остаётся консервативным (без умной линковки). Увы, это ограничение SDCC
(Я узнал, что такое поведение типично для многих других компиляторов Си, например Tiny C).

Ветка форума, посвящённая "умной" линковке: http://zx.oberon2.ru/forum/viewtopic.php?f=10&t=34


Полезные горячие клавиши в системе BlackBox
===========================================

(для тех, кому надо быстро)

F11
---
Транслировать текущий открытый в редакторе модуль с помощью подсистемы Ofront
с языка Оберон-2 в текст программы на Си.

F12
---
Компилировать текущий открытый в редакторе модуль с помощью подсистемы Dev
с языка Оберон-2/Компонентный Паскаль в кодовый Оберон-файл .ocf и символьный
файл .osf, выгрузить данный модуль из памяти (если загружен и если это возможно).

Ctrl+D
------
Показать клиентский интерфейс (аналог *.h в Си) выделенного модуля.
Выделите мышкой (или клавишами <-- и --> с Shift) имя модуля и нажмите Ctrl+D
( Работает только для модулей, скомпилированных подсистемой Dev ).

F9
--
Сравнить два открытых файла на предмет различий (подсвечиваются).

Сделать выделенный фрагмент текста форматированием как другой текст
-------------------------------------------------------------------
Выделить текст, нажать Alt и тащить мышку на новое форматирование.


Как создать новый проект
========================

Вот начальное руководство по написанию программ для Speccy на ZXDev kit.

1) Запустите BlackBox.exe в основной папке XDev

2) File -> New (чтобы создать файл Оберон-модуля) или File -> Open (для редактирования существующего
   модуля). Готовые примеры лежат в папке ZXDev/Mod, имена файлов модулей имеют расширение .odc.

3) Когда всё будет готово для компиляции, сохраните модуль File -> Save (или Ctrl+S). Лучше если
   имя модуля задано латинскими буквами (русскими не проверял).

4) Теперь выберите Translate в меню Ofront (или просто нажмите F11). Если в процессе компиляции
   возникнут ошибки, исправьте их и снова нажмите F11 до тех пор пока в окне Log будет что-то вроде:

   translating TinyHello    259

5) Это значит, что Ofront успешно перевёл Оберон-модуль в текст на языке Си и поместил файлы
   имя_модуля.h, имя_модуля.c и имя_модуля.sym в папку Ofront/Obj

6) Скопируйте имя_модуля.c и имя_модуля.h оттуда в главную папку ZXDev (в дальнейшем можно написать
   .bat-файл, который будет копировать автоматически - примеры смотрите в ZXDev/*.bat).

7) Скопируйте один из существующих в папке ZXDev *.trl файлов в имя_модуля.trl (имя должно
   соответствовать вашему проекту) и исправьте внутри него имя .bin файла в соответствии с
   вашим проектом (утилита bin2trd понимает только короткие 8.3 имена файлов).

8) Откройте файл имя_модуля.trl и отредактируйте его, задав собственное имя модуля:

;my disk

EXTENDED "ZXDev"
HOBETA "Bin\Boot.$b","boot","B"
BINARY "имя_модуля.bin","Dash","C",26000
;end of disk

9) Убедитесь, что верно указали вместо имя_модуля.bin правильное имя вашего модуля.

10) Скопируйте один из существующих в папке ZXDev *.bat файлов в имя_модуля.bat и переименуйте его
    в соответствии с именем вашего модуля.

11) Измените в файле имя_модуля.bat все имена файлов и пути в соответствии с именем вашего модуля
    (лучше всего через поиск/замену в Блокноте).

12) Не забудьте переименовать в строке вызова trd2bin имя_модуля на короткое имя DOS (8.3)
    (см. как это сделано в ZXDev/*.bat, как правило, заканчивается на "~ 1")!

13) Запустите командный файл для создания файла имя_модуля.trd

14) .trd-файл можно запустить в эмуляторе (Выберите TR-DOS, а затем исполните команду RUN)

Если это кажется вам длинным и непонятным, понимание прийдёт с опытом, это не придётся делать часто.

Автор данного вводного руководства kgmcneil. Большое спасибо ему.


Благодарности
=============

- Евгению Михайлову (HVG) и Игорю Мазнице (Raydac) за разработку и распространение
    декомпилированной командой Raydac Soft'93 A.G. библиотеки Laser Basic.
- Bernhard Treutwein - за полезные посты. Этот человек пришёл на иноязычный для него
    форум просто для того, чтобы поделиться находкой - утилитой для конвертации
    сишных заголовков (*.h) в интерфейсы для Компонентного Паскаля. Низкий поклон.
- Philipp Klaus Krause - за отличный кодогенератор для процессора Z80.
- Josef Templ - за перевод транслятора Оберона-2 в Си Ofront на FreeBSD-style-лицензию.
    Это одним махом сняло массу проблем по доработке ZXDev до любой нужной возможности.
- grischka - за продолжение совершенствования компилятора Tiny C.
- kgmcneil - за вводное руководство по созданию нового проекта и интерес к ZXDev.


Известные проблемы
==================

1. Сейчас исполнение программы начинается с самой первой процедуры, объявленной
   в линкуемом как основной модуле (или с самого начала модуля, короче говоря).
   Данное ограничение вызвано тем, что не используется сишная функция main().

   Обходить предлагаю так. Вынесите стартовую точку программы в отдельный модуль
   и расположите её между BEGIN и END основного стартуемого модуля. Если такой
   вариант по каким-либо причинам нежелателен, примите стартовой точкой первую
   процедуру линкуемого как главный модуля, со всеми вытекающими.

2. SDCC пока не умеет компилировать вот такой код присвоения структур:
   http://sourceforge.net/tracker/?func=detail&atid=350599&aid=3452891&group_id=599
   А Ofront такой код создаёт. Обещают в SDCC фичу эту добавить. Даже приоритет
   повысили несколько раз. Здесь видится несколько решений. В порядке повышения
   сложности где-то так:

   a) не использовать присваивания вида:

   TYPE
     Card = RECORD suit*, rank*: INTEGER END;
   VAR
     a, b: Card;
   BEGIN
     a := b;

   Обойдясь таким поэлементным присваиванием:

     a.suit := b.suit; a.rank := b.rank;

   b) использовать автоматическую обработку промежуточного Си-файла, заменив в нём
      подходящим инструментом указанные присваивания “a := b” на
      “a.suit := b.suit; a.rank := b.rank”
      Это решение не очень красивое, но плюс: Оберон-исходник остаётся красивым.

   c) ждать пока в SDCC добавят нужную нам рюху (ещё пока не добавили):
      http://sourceforge.net/tracker/index.php?func=detail&aid=1710546&group_id=599&atid=350599


   d) наиболее правильным видится доработать Ofront, чтобы сам генерировал
      поэлементное присваивание записей (или что-то вроде memcpy(a, b, sizeof(Card)) )
      [опционально включаемое]. Это вполне возможно, правда, я не понял, разрешает ли
      лицензия его доработку. Надо уточнить у Джозефа Темпла.


TODO
====

- Сейчас в библиотеке Basic поддержан только режим DI. Планируется добавить
    поддержку режимов IM0 и IM2. Реализовать режим IM0 стало возможно благодаря
    применению ключа SDCC --reserve-regs-iy, который запрещает компилятору
    использовать регистр IY).
- Добавить сжатие целевого бинарника упаковщиком Hrust 1.3
- Добавить подсистему для автоматической подсветки синтаксиса модулей:
  (Начать отсюда: http://forum.oberoncore.ru/viewtopic.php?f=114&t=3864 )


Сейчас раскрашиваю синтаксис так
================================

notepad++ (со схемой Pascal)
Дополнения -> NppExport -> Copy RTF to clipboard
Вставить в BlackBox раскрашенный текст Ctrl+V
Дораскрашивать путём перетаскивания с Alt выделенного текста
на текст с нужным форматированием.


Беззнаковые типы и препроцессор
===============================
Как же без них? Функционал препроцессора предлагаю возложить на селекторы -

  DevSelectors - переключатели вариантов в исходном коде -

  http://oberoncore.ru/wiki/blackbox/devselectors
  http://forum.oberoncore.ru/viewtopic.php?f=1&t=435

Введена ограниченная поддержка беззнаковых типов. Реализуется так:

IMPORT SYSTEM;

TYPE
(* System platform dependent types. Use its in system code. *)
	BYTE = SYSTEM.SHORTCARD;
	WORD = SYSTEM.CARDINAL;
	DWORD = SYSTEM.LONGCARD;
(* System platform independent types. Use as bases in type aliasing. *)
	SHORTCARD = SYSTEM.SHORTCARD;
	CARDINAL = SYSTEM.CARDINAL;
	LONGCARD = SYSTEM.LONGCARD;
(* System platform independent types. Use directly like other types. *)
	ShortCard = SYSTEM.SHORTCARD;
	Cardinal = SYSTEM.CARDINAL;
	LongCard = SYSTEM.LONGCARD;

Известное ограничение: при экспорте беззнаковые типы приравниваются к знаковым.

Ввиду отсутствия интереса широкой общественности к Оберон-разработке для ZX
это направление работ свёрнуто.


Рекомендуемые соглашения
========================

Оберон, Оберон-2
----------------
1. Типы, Процедуры, Константы - называем с большой буквы; переменные - с маленькой буквы;
процедурные переменные - с маленькой буквы, даже если они являются параметрами или полями записи.
Их и так видно, что они процедуры, когда их вызываешь, – по скобкам.
Переменная – значит с маленькой буквы, всё остальное с большой. Вот моё правило. (с) Алекс Ильин

2. Не используем идентификаторов, которые целиком состоят из заглавных букв. Это мешает беглому
отделению взглядом идентификаторов от конструкций языка. Используем такие идентификаторы ТОЛЬКО
в особых случаях, чтобы подчеркнуть их особое значение. Например, в подсистеме Active BlackBox
(автор: Илья Ермаков) используются идентификаторы Ao.MONITOR, Ao.EXCLUSIVE, Ao.AWAIT, Ao.ACTIVE -
их особая роль состоит в управлении многопоточностью, поэтому они выделены на правах равнозначных
конструкций языка. Кстати, именно продемонстрированная возможность расширения языка КП введением
многопоточности (на уровне библиотеки) свидетельствует о необычайной мощности и гибкости
Оберон-технологий. Подобным же образом можно добавить любые другие конструкции, например,
для обработки исключений (последняя возможность уже встроена в ядро BlackBox).

3. В конструкциях CASE и WITH добавляем для симметрии и красоты "лишний" символ "|":

CASE c OF
  | " ": (* Space *);
  | Tab: (* Tab *);
END;

Это также повышает наглядность при восприятии программы. Это правило только для многострочной
записи. Если CASE и WITH умещается в одной строке, "лишний" символ "|" не пишем:

CASE c OF " ", Tab: ELSE (* Это не пробел и не табуляция *) END;

4. Точку с запятой ";" ставим после END всегда, за исключением случаев:

a) обязательно не ставим ";" после RETURN (если дальше END) и после EXIT (если дальше END);
b) не ставим ";" перед END если конструкция уместилась в одну строку:
   IF a = b THEN a := 2 END; (* <-- Такое системе контроля версий не страшно. *)

Обоснование: http://forum.oberoncore.ru/viewtopic.php?f=29&t=3892

Ассемблер
---------
Ассемблерные команды в сишных обвязках всегда пишем БОЛЬШИМИ буквами -
дань традиции старых 8-битных компов, в которых поначалу даже не было строчных литер,
а также классике спектрумных книг, в которых тоже придерживаются данного соглашения
(например, см. листинги в книге "Как написать игру на ассемблере для ZX Spectrum").

Если пожелаете добавить к проекту ZXDev свои разработки, следование данным соглашениям обязательно.


Отладка
=======

Я использую для отладки ASSERT'ы, и debug-вставки с отладочной распечаткой.

-------------------------------------------------------------------------------------
MODULE Sets; (* portable *)

CONST
  Debug* = TRUE;

END Sets.

MODULE Grx; (* portable *)
IMPORT Sets, Debug;
...

PROCEDURE PutSprite* (x, y: SpriteCoords; spr: Sprite);
BEGIN
  IF Sets.Debug THEN (* Это прямой аналог ifdef'а, однако если Debug = FALSE,
                        то никакого лишнего кода в прогу не вставится *)
    CASE x OF 0..MaxX: CASE y OF 0..MaxY: ELSE Debug.Stop("Bad sprite coords!") END END;
  END;
  ...
END PutSprite;

END Grx.
-------------------------------------------------------------------------------------

Для профилирования использую эмулятор FUSE. В качестве пошагового отладчика –
эмулятор Владимира Кладова EmuZWin. Так и баги в кодогенераторе SDCC искал,
так и свои проги дебажил. Я также не против иметь готовый пошаговый отладчик
Оберон-программ чисто для Z80. Осталось его написать.


Предполагаемые направления дальнейшей деятельности
==================================================

1. Адаптация к технологии  ZXDev библиотек MegaBasic, Supercode, Supercode 2 и New Supercode.
2. Адаптация к ZXDev библиотеки Sprite Pack из Z88DK ( http://www.timexsinclair.org/alvin/#SP ,    http://www.mojontwins.com/warehouse/splib2-tutorial.pdf ). Ещё посмотреть в эту сторону:
   http://www.z88dk.org/wiki/doku.php  http://www.z88dk.org/wiki/doku.php?id=library:sprites:sp1
3. Адаптация к ZXDev наработок SerzhSoft’а, в частности, “40 лучших процедур” ( http://vladik1232008.narod.ru/ZX_FORUM_40_Best_procedures.html , http://vladik1232008.narod.ru/ZX_Review11_12.html )
4. Портирование с Hisoft Pascal библиотеки для черепашьей графики Turtle.
5. Адаптация к ZXDev процедуры NiceType (красивый вывод текста) с моей игры Sea Fight  ( http://colossoft.anarxi.st/?go=seafight ).
6. Порт игры “Бега Мышей” (из книги “Как написать игру для ZX Spectrum”) с Laser Basic на Оберон-2
 (в качестве демонстрации технологии ZXDev), можно также портировать демонстрашку из поставки Laser Basic'а.
7. Порт игры Laser Cube с Laser Basic на Оберон-2 с целью её ускорения.
8. Порт игры Dark Woods для ZX Spectrum ( http://zx.pk.ru/showthread.php?t=18457 ).

Следует предпринять и такие шаги:

1. Доработка Офронта для решения этой проблемы: ( http://sourceforge.net/tracker/?func=detail&atid=350599&aid=3452891&group_id=599 ).
2. Доработка Ofront до возможности полноценно использовать линейку беззнаковых типов 
   в программах на Обероне – SHORTCARD (8 бит), CARDINAL (16 бит), LONGCARD (32 бита),
   что важно для оптимальности алгоритмов при разворачивании кода на процессор Z80.
   Название типов исходит из языка Модула-2, но обсуждаемо.
3. Разработка быстрой графической библиотеки для ZX Spectrum (оконное GUI, шрифты
   разных размеров, заливка текстурой, спрайты, тайлы, векторная графика с масштабированием).
   Создание аналогичной по функционалу и по вызовам библиотеки для других платформ
   (для облегчения переноса игр со Спектрума и для одномоментной разработки
   для Спектрума и чего-то ещё).
4. Совершенствование подсистемы ZXDev для упрощения разработки (чтобы новичкам легче было
   создавать на Обероне программы для ZX Spectrum), наращивание её возможностей новыми
   библиотеками и насыщение идеями, создание информационного пространства в рамках
   технологии “ZX+Oberon”.
5. Дальнейшая доработка Офронта до транслятора, включающая поддержку языка Component Pascal,
   с возможностью использовать язык КП для программирования процессора Z80.

Я не собираюсь реализовывать всё вышеперечисленное сам, всего на свете не сделаешь,
поэтому будем посмотреть, какой это вызовет интерес и одобрение у вас. Также буду рад
услышать мнения, какие пункты считаете более приоритетными.


Лицензия
========

Подсистему ZXDev разрешается использовать для любых коммерческих или некоммерческих
применений свободно. Любая помощь в работе, даже мельчайшая, будет очень кстати.
Учитывайте, что готовые компоненты, входящие в XDev, могут распространяться
под своей личной лицензией.


ЧАВО
====
Вопрос. Зачем в библиотеки включаются эти хвосты типа Best40_attrib, Best40_ASRL_LF и т.д.?

Ответ. Это нужно для совместного использования библиотек сишным компилятором. Допустим,
к проекту подключаются библиотеки Basic и Best40, в каждой из них есть функция POINT.
Получается накладка идентификаторов и "несовместимость" библиотек, невозможность использовать
их совместно без ухищрений. В Обероне, в отличии от Си, импорт квалифицированный, т.е.
с обязательным указанием модуля, откуда используется функция. И возможно совместное
использование библиотек (обращение происходит к Best40.POINT и Basic.POINT). Поэтому
чтобы при работе с библиотеками убрать влияние сишных идентификаторов друг на друга и
сохранить возможность совместного использования мы применяем жёстко заданный префикс
(Best40_ или Basic_), эмулируя квалифицированный импорт из Оберонов. Также поступает
и Ofront. В то же время, остаётся возможность из сишных частей программы вызывать
такие функции без префиксов, что реализуется с помощью препроцессора.


Авторские права
===============

Сборка XDev и подсистема ZXDev - VEDAsoft - Oleg N. Cher
  ( http://zx.oberon2.ru  ICQ 2-20-84-03  allot -bk- ru )

BlackBox Component Builder - Oberon microsystems AG - www.oberon.ch

Пакет русской документации для BlackBox 1.6 - проект ИНФОРМАТИКА-21

Ofront - Software Templ OG - www.software-templ.com/shareware.html

Small Device C Compiler - SDCC Team - http://sdcc.sourceforge.net/

Laser Basic for ZX Spectrum - Oasis Software (Kevin Hambleton) -
    http://www.worldofspectrum.org/infoseekid.cgi?id=0008327
  E.Michailov (HVG) -
    http://zx.pk.ru/showthread.php?t=11615
PC110 Micro C (+Laser Basic lib) - Raydac Soft'93 A.G. (I.Maznitsa, E.Michailov)

BIN2TRD - Copper Feet '1999 (V.Mednonogov)

HEX2BIN - Rockwell Automation (Jacques Pelletier)

StripBIN, SmartLinkRel - VEDAsoft - Oleg N. Cher

Win_TZX2TAP - Leszek Chmielewski - http://www.worldofspectrum.org/utilities.html

H2O - Stewart Greenhill - http://sourceforge.net/projects/ooc/files/ooc2/

Tiny C - Fabrice Bellard - http://bellard.org/tcc/
