<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Oberon2005.ru</title>
  
<link rel="StyleSheet" type="text/css" href="f01style.css">
<style>

h1 {color: #f0f0f0; font:bold 180% arial,sans-serif;}


body, td {font-family: Arial, Geneva CY, Sans-Serif; font-size: 80%;}
.header {background-color:#006699}
.footer {background-color:#f0f5ff}
.also {font:80%; background:#f0f0f0;}
.also2 {font:80%; background:#efefef;}
.news {font:80%;background:#ffffff;}

.softbg {background:#DDDDDD;}
.clear {background:#ffffff;}

.force {
  letter-spacing: 0.1em;
  margin-left: 0.2em;
  margin-right: 0.2em;
}

</style></head>


<body topmargin="0" bgcolor="#ffffff" marginheight="0">
<table border="0" cellpadding="5" cellspacing="0" width="100%">
 <tbody><tr>
  <td class="header" colspan="2"><a href="http://www.oberon2005.ru/" class="header"><div align="center">Никлаус&nbsp;Вирт&nbsp;&nbsp;в&nbsp;&nbsp;России<br>Niklaus&nbsp;Wirth&nbsp;&nbsp;in&nbsp;&nbsp;Russia</div></a></td>
 </tr>
</tbody></table>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
 <tbody><tr>
  <td><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><table border="0" cellpadding="0" cellspacing="0" height="10" width="1"><tbody><tr><td></td></tr></tbody></table></td></tr></tbody></table></td>
 </tr>
</tbody></table>


<table border="0" cellpadding="0" cellspacing="0" width="100%">
 <tbody><tr>
  <td class="softbg"><table border="0" cellpadding="8" cellspacing="1" width="100%">
 <tbody><tr>
  <td class="softbg" width="75%"><strong><a href="http://www.oberon2005.ru/">Главная страница</a>
    &nbsp;/&nbsp;
    
    Оберон. Коротко о главном
    
    </strong></td>
  <td class="softbg" width="25%"><strong>БОЛЬШОЕ ТУРНЕ&nbsp;&nbsp;Н.&nbsp;ВИРТА</strong></td>
 </tr>
 <tr>
  <td class="clear" valign="top">
<p><font color=#0000FF size=4><strong>Оберон. Коротко о главном. Часть 2
</strong><br>Краткие ответы на ключевые вопросы (техническая часть)</font><br>
<ol>
<li>Правда ли, что в Обероне убраны паскалевские скобки <b>begin-end</b>?</li>
<li>Почему все зарезервированные слова в Обероне записываются большими буквами?</li>
<li>Почему Оберон не имеет оператора <b>goto</b>?</li>
<li>При отказе от использования <b>goto</b> проводились ли исследования о практике применения этого оператора в других языках?</li>
<li>Что Вирт исправил в операторе <b>IF</b>?</li>
<li>Почему из Оберона исключены перечисления и диапазоны?</li>
<li>Почему индексы массивов всегда нумеруются от нуля?</li>
<li>Почему в Обероне нет цикла <b>FOR</b> ?</li>
<li>Зачем из Оберона исключены вариантные записи?</li>
<li>Почему в Обероне нет обработки исключений?</li>
<li>Чем принципиально отличается поддержка ООП в Обероне от ее воплощения в ведущих промышленных языках?</li>
<li>Что такое модуль в понимании Оберона и чем модульное программирование помимо
 отсутствия полиморфизма и наследования отличается от ООП?</li>
<li>Почему в Обероне нет ничего подобного P-коду? Его ведь создал Вирт, а идеи использовались 
потом в Java и .NET.</li>
</ol></p>
<br>
<p><b>1.&nbsp;Правда ли, что в Обероне убраны паскалевские скобки begin-end?</b></p>

<div align="justify"><p>Да, это было сделано Виртом еще в языке Modula-2 (1979). Начало 
синтаксической конструкции (ветвления и цикла) уже определяется первым словом этой 
конструкции (<b>IF</b>, <b>CASE</b>, <b>WHILE</b>, <b>REPEAT</b>, <b>LOOP</b>), поэтому 
слово <b>BEGIN</b> здесь излишне. Для тел 
инициализации модулей и тел процедур скобки <b>BEGIN-END</b> используются, но с некоторой 
модификацией — обязательным указанием после <b>END</b> имени соответствующего модуля/процедуры.</p></div>
<br>
<p><b>2.&nbsp;Почему все зарезервированные слова в Обероне записываются большими буквами?</b></p>

<div align="justify"><p>Этот подход был введен Виртом еще в языке Modula-2 и показал свою 
высокую ценность в плане четкого выделения структуры исходного текста. Он был заимствован 
из языка Mesa (1975), разработанного в Xerox PARC. С появлением синтаксически ориентированных 
редакторов, позволяющих цветом выделять зарезервированные слова, достоинства такого 
подхода стали не столь явными. Однако, не следует забывать, что цветовое выделение 
не стандартизировано (ни для одного из популярных языков) и теряется при публикации 
в печатных и электронных изданиях, а также в ходе электронной переписки. Относительное 
неудобство переключения регистров при наборе текста легко компенсируется средствами 
соответствующей системы программирования (IDE).
</p></div>

<br>
<p><b>3.&nbsp;Почему Оберон не имеет оператора goto?</b></p>

<div align="justify"><p>Оператор <b>goto</b> был изъят Виртом из Паскаля еще при создании языка 
Modula-2 (1979). Обоснование изъятия <b>goto</b> из языков высокого уровня было предложено в 
известной работе Эдсгера Дейкстры (Edsger W. Dijkstra <a href="http://www.acm.org/classics/oct95/" target="_blank">"Go To Statement Considered Harmful"</a> 
// Communications of the ACM, Vol. 11, No. 3, March 1968).</p>

<p>Как показывает практика программирования (особенно последних лет) используют <b>goto</b> отнюдь 
не для оптимизации объектного кода, а, как правило, чтобы сэкономить свое время на 
кодирование конкретного алгоритма. </p> 

<p>Следует отметить:</p>

<p>1.&nbsp;Оператора <b>goto </b>нет в таких языках, как Smalltalk (А.Кей, 1972), Modula-2 (Н.Вирт, 
1979), Eiffel (Б.Мейер, 1986), Оберон (Н.Вирт, 1987), Modula-3 (DEC SRC, 1988), Оберон-2 
(Х.Мессенбок, 1991), Java (Дж.Гослинг, 1995), Компонентный Паскаль (Oberon microsystems, 
1997). Это далеко не полный перечень.
<br><br>
2.&nbsp;Оператор <b>goto</b> более чем проблемно использовать в блоках контроля и обработки 
исключений вне зависимости от того, включен ли механизм обработки исключений в язык или он 
поддерживается на библиотечном уровне.</p>

<p>В одних языках (Modula-2, Оберон и др.) <b>goto</b> часто моделируется связкой <b>LOOP</b>-<b>END</b> с 
оператором <b>EXIT</b>, в других для этой цели применяют в том числе и программные исключения 
(exceptions), которые не только позволяют корректно передавать управление на нужную точку, 
но и нивелировать последствия такого нарушения линейного исполнения кода (утилизация 
ресурсов, обработчики исключений и т.п.).</p>

<p>При этом следует упомянуть, что обоснованность использования <b>goto</b> в языке высокого уровня 
отстаивается до сих пор. Самый яркий пример последних лет — язык C# (Microsoft, 2000).
</p></p></div>
<br>
<p>
<b>4.&nbsp;При отказе от использования goto проводились ли исследования о практике 
применения этого оператора в других языках?</b></p>

<div align="justify"><p>Есть интересные данные, полученные в ходе исследований Марком 
Брандисом (Marc Brandis) из ETH Zurich. Результаты работы включены в доклад, 
представленный на конференции по модульным языкам программирования в Ульме 
(Joint Modular Language Conference, 1994).</p>

<p>В качестве сравнения брались крупные системы, реализованные на Си.</p>

<p>1.&nbsp;X Window 11 R5 (MIT)<br>
2.&nbsp;GNU C Compiler 2.6.0 (для IBM RS/6000), Free Software Foundation<br>
3.&nbsp;ANSI C Compiler LCC 3.0</p>

<p>Сначала проводилась фильтрация: например, в GNU CC кол-во <b>goto</b> было 5701, потом выяснилось, 
что более 5000 лежали в одном-единственном файле, где реализовывался конечный автомат. 
Причем текст автомата генерировался автоматически из описания. Естественно из расчета 
этот фрагмент выбросили.</p>
<br><br>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
 <tr>
  <td class="softbg"><b>пакет</b></td><td class="softbg"><b>исх.файлов</b></td><td class="softbg"><b>строк</b></td><td class="softbg"><b>#goto</b></td><td class="softbg"><b>строк/goto</b></td>
 </tr>
 <tr>
  <td class="also">X Window 11 R5</td><td class="also">1747</td><td class="also">735038</td><td class="also">900</td><td class="also">817</td>
 </tr>
 <tr>
  <td class="softbg">GNU CC 2.6.0</td><td class="softbg">111</td><td class="softbg">288510</td><td class="softbg">679</td><td class="softbg">425</td>
 </tr>
 <tr>
  <td class="also">LCC 3.0</td><td class="also">29</td><td class="also">24684</td><td class="also">18</td><td class="also">1371</td>
 </tr>
 <tr>
  <td class="softbg"><b>всего</b></td><td class="softbg"><b>1887</b></td><td class="softbg"><b>1048232</b></td><td class="softbg"><b>1597</b></td><td class="softbg"><b>656</b></td>
 </tr>
 </table>
<p></p>
<p>Вывод Брандиса: относительно небольшое кол-во <b>goto</b> говорит о том, что структурное 
программирование не забывают и в Си. Более того, выявилась тенденция концентрации <b>goto</b> 
в небольшом числе файлов. Так, напр., ни одного <b>goto</b> не было в 92% исходных текстов 
(смотрелись только *.c) для X Window, в 50% для GNU CC и в 90% для LCC. Брандис приводит 
подробный график распределения, из которого видно, что критичные 5, 20, 100 и 200 строк 
на одно <b>goto</b> занимают от 20 до 500 файлов (в основном в X Window).</p>
<p>
Выводы исследования:</p>

<p>1.&nbsp;Скрытые <b>goto</b> в программах — вполне нормальное явление и не нужно пытаться обязательно 
от них избавляться. Чаще всего, оптимизирующий компилятор сделает это при необходимости сам.
<br><br>
2.&nbsp;Что касается обычного <b>goto</b>, то лучше, когда в языке его нет, но когда он есть, то 
концентрируется обычно там, где код пишется неаккуратно (плохой стиль конкретного 
программиста).</p>


<p>В рамках данного исследования изучалась также частота использования различных операторов 
цикла языка Оберон на основе анализа исходных текстов системы Oberon System 
(для IBM RS/6000).</p>
<p>
По циклам в Обероне выявилось, что из 1479 циклов доля <b>WHILE</b> — 1113 (75,2%), <b>REPEAT</b> — 232 
(15,7%), а <b>LOOP</b> — 134 (9,1%).  <b>LOOP</b> с одной точкой выхода (<b>EXIT</b>) Оберон-программисты 
использовали, чтобы избегать дублирования кода. Но можно легко трансформировать эту 
структуру в <b>WHILE</b>.</p>

<br><br>Фрагмент
<table width="100%" border="0" cellspacing="0" cellpadding="2">
 <tr>
  <td width="5%"></td> 
  <td><font size="3"><pre><b>LOOP</b>
  stat0;
  <b>IF</b> pred <b>THEN EXIT END</b>;
  stat1
<b>END</b>;</pre></font></td>
 </tr>
</table>

эквивалентен
<table width="100%" border="0" cellspacing="0" cellpadding="2">
 <tr>
  <td width="5%"></td> 
  <td><font size="3"><pre>stat0;
<b>WHILE</b> ~pred DO
  stat1;
  stat0
<b>END</b>;</pre></font></td>
 </tr>
</table>

<p>Интересно отметить, что Гризмер (Griesmer) переписал фрагменты своего компилятора Oberon-V, 
избавившись от <b>LOOP</b> в пользу <b>WHILE</b>. При этом он обнаружил, что в большинстве случаев текст 
стал понятней.</p>
</div>
<br>
<p><b>5.&nbsp;Что Вирт исправил в операторе IF?</b></p>

<div align="justify"><p>Оператор <b>if-then-else</b>, пришедший из языка Алгол-60 и включенный 
Виртом в Паскаль, является неоднозначным, когда он вложен в другой <b>if-then-else</b>: не 
очевидно, к какому <b>if</b> относится данная <b>else</b>-часть.</p>

<p>В своей лекции "Good Ideas — Revised" в МГУ (19.09.2005) Никлаус Вирт привел такой пример:</p>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
 <tr>
  <td width="5%">&nbsp;</td> 
  <td width="95%"><font size="3"><pre><b>if</b> b0 <b>then</b> <b>if</b> b1 <b>then</b> S0 <b>else</b> S1
</pre></font></td>
 </tr>
</table>

<p>Из него не ясно, как трактовать данную конструкцию:</p>

<table width="100%" border="0" cellspacing="0" cellpadding="2">
 <tr>
  <td width="5%">1.</td> 
  <td><font size="3"><pre><b>if</b> b0 <b>then</b> <font color=#00008B><b>if</b> b1 <b>then</b> S0 <b>else</b> S1</font></pre></font>
  </td>
 </tr>
 <tr>
  <td width="5%">2.</td> 
  <td><font size="3"><pre><font color=#00008B><b>if</b> b0 <b>then</b></font> <b>if</b> b1 <b>then</b> S0 <font color=#00008B><b>else</b> S1</font></pre></font>
  </td>
 </tr>
</table>
<br>
<p>В языке Modula-2 эта ошибка была Виртом устранена путем замены <b>if-then</b> на <b>IF-THEN-END</b> и 
<b>if-then-else</b> на <b>IF-THEN-ELSE-END</b>, точнее говоря, включением <b>END</b> в состав этой конструкции 
ветвления</p>. 

<table width="100%" border="0" cellspacing="0" cellpadding="2">
 <tr>
  <td width="5%"></td> 
  <td><font size="3"><pre><b>IF</b> b0 <b>THEN</b>
  <b>IF</b> b1 <b>THEN</b> S0 <b>ELSE</b> S1 <b>END</b>
<b>END</b>;</pre></font></td>
 </tr>
</table>

или<br>

<table width="100%" border="0" cellspacing="0" cellpadding="2">
 <tr>
  <td width="5%"></td> 
  <td><font size="3"><pre><b>IF</b> b0 <b>THEN</b>
  <b>IF</b> b1 <b>THEN</b> S0 <b>END</b>
<b>ELSE</b> S1
<b>END</b>;</pre></font></td>
 </tr>
</table>

<p>Оператор стал однозначным, даже если в нем используется много вложенных 
<b>IF-THEN-ELSE-END</b>. Кроме того, Вирт включил в оператор <b>IF</b> и <b>ELSIF</b>-часть, чтобы удобнее 
и нагляднее было применять каскадный оператор ветвления без необходимости изменения 
уровня вложенности.</p>
</div>
<br>
<p><b>
6.&nbsp;Почему из Оберона исключены перечисления и диапазоны?</b></p>

<div align="justify"><p>Перечисление (enumeration) — довольно удобный тип, введенный 
в языке Паскаль (1970) и сохраненный в Modula-2 (1979). Тем не менее, в Обероне 
он исключен.</p>

<p>Причин несколько: во-первых, при введении в Обероне нового механизма расширения типов 
выясняется, что этот тип становится особым — его нельзя расширять. Кроме того, поскольку 
тип перечисление определяется совокупностью идентификаторов констант, то при экспорте 
требуется передавать все значения (хотя наличие спецификаторов экспорта позволяет 
экспортировать значения на выбор). Это ввело бы ненужную путаницу. Вирт принял решение 
отказаться от перечислений, считая, что вполне достаточно в случае острой необходимости 
имитировать такой тип набором констант.</p></div>

<table width="100%" border="0" cellspacing="0" cellpadding="2">
 <tr>
  <td width=15%></td>
  <td><div align="justify"><p><i>Тип перечисление — слишком простое средство, чтобы оно могло выйти из-под контроля. 
Однако, оно не позволяет распространять расширяемость за пределы модуля. И либо нужно 
ввести средство для расширения типа перечисление, либо же от типа перечисление надобно 
отказаться. Причина, по которой мы выбрали второй путь — путь радикального решения — 
кроется в том, что во все возрастающем числе программ непродуманное использование 
перечислений (и диапазонов) ведет к демографическому взрыву среди типов, что, в свою 
очередь, ведет не к ясности программ, а к их многословию. В связи с использованием 
экспорта и импорта перечисления приводят к исключению из правил, и согласно ему импорт 
идентификатора типа также приводит к автоматическому импорту всех связанных с типом 
идентификаторов констант. Это исключение нарушает концептуальную простоту и создает 
для реализаторов языка неприятные проблемы. </i></p>

<div align="right"><p>Niklaus Wirth. From Modula to Oberon (1988)</p></div>
</div>
</td>
 </tr>
</table>

<div align="justify"><p>Диапазоны (subrange) также исключены из Оберона, хотя и были представлены в Modula-2. 
Чаще всего диапазоны использовались в качестве типов индексов для массивов. В Обероне 
Вирт принял решение вернуться к тому, что было введено еще в Си (1971) — все массивы 
нумеруются от нуля. Понятно, что “абсолютные адреса” (индексы в рамках диапазонов) 
легко отобразить на “относительные” (от нуля). Иными словами, эта забота перекладывается 
на плечи программиста. Но в подавляющем большинстве случаев она не является серьезным 
ограничением.</p></div>

<table width="100%" border="0" cellspacing="0" cellpadding="2">
 <tr>
  <td width=15%></td>
  <td><div align="justify"><p><i>Типы диапазонов были введены в Паскале (и сохранены в 
Modula-2) по двум причинам: (1) чтобы подчеркнуть тот факт, что переменная принимает 
значения из ограниченного диапазона базового типа, и чтобы дать возможность компилятору 
генерировать соответствующий проверочный код для присваиваний; (2) чтобы позволить 
компилятору выделять минимально необходимое пространство памяти для хранения значений 
из указанного диапазона. Это желательное свойство в плане использования упакованных 
записей. Лишь в небольшом числе реализаций используется данное преимущество экономии 
памяти, поскольку при этом компилятор довольно значительно усложняется. 
Причины под номером (1) явно недостаточно, чтобы оставить в Обероне работу 
с диапазонами. </i></p>

<div align="right"><p>Niklaus Wirth. From Modula to Oberon (1988)</p></div>
</div>
</td>
 </tr>
</table>


<br>
<p><b>
7.&nbsp;Почему индексы массивов всегда нумеруются от нуля?</b></p>

<div align="justify"><p>Это следствие исключения из языка перечисления и диапазонов 
(см. ранее). Достаточно радикальное решение, безусловно упрощающее язык и компилятор, 
но создающее определенные неудобства программисту. Положительный момент такого решения в 
том, что он стимулирует всегда рассматривать в качестве нижней границы индекса только 0. 
Нередко же в качестве нижней границы в Паскале и Modula-2 выбирают, не задумываясь 1, 
а затем уже, спустя некоторое время, приходят к мысли о том, что 0 более удобен (в 
частности, при выполнении циклических преобразований с индексом).</p></div>

<table width="100%" border="0" cellspacing="0" cellpadding="2">
 <tr>
  <td width=15%></td>
  <td><div align="justify"><p><i>Понятие определяемого программистом типа индексов для 
массивов также не вошло в Оберон: теперь все индексы могут быть только целыми числами. 
Более того, нижняя граница индексов теперь строго равна 0 и в описании массива фигурирует 
только количество элементов, а не пара значений, определяющих границы индексов. Этот отход 
от уже устоявшейся традиции, восходящей своими корнями еще к языку Алгол-60, наглядно 
демонстрирует принцип удаления из языка всего несущественного. Спецификация произвольной 
нижней границы вряд ли придает языку дополнительную выразительную силу. В то же время 
это является скорее ограниченным видом отображения индексов, которое ведет к скрытым 
вычислениям, не сравнимым с удобством использования. Скрытые накладные расходы проступают 
особенно сильно при проверке границ и при работе с динамическими массивами.</i></p>

<div align="right"><p>Niklaus Wirth. From Modula to Oberon (1988)</p></div>
</div>
</td>
 </tr>
</table>

<br>
<p><b>8.&nbsp;Почему в Обероне нет цикла FOR ?</b></p>
<div align="justify"><p>Это не совсем так. Цикл <b>FOR</b> использовался в языке Modula-2, но в Обероне сначала был изъят. 
Это обусловлено тем, что большое количество ошибок программирования возникает именно при 
использовании данного цикла.</p>

<p>Из-за простоты формы его использованием нередко злоупотребляют в тех случаях, когда другие 
виды операторов цикла (с предусловием — <b>WHILE</b> и с постусловием — <b>REPEAT</b>) более 
предпочтительны. Особый случай — переменная цикла.</p>

<p>Для надежности область ее видимости (и область существования) должна ограничиваться рамками 
цикла (быть неопределенной, а еще лучше — невидимой, до и после цикла). Именно такой подход 
был взят на вооружение в языке Modula-3 (1988), разработанном в DEC Systems Research Center 
и Olivetti на базе языка Modula-2. Почему — понятно. Многие ошибки возникают из-за того, 
что за рамками цикла используется эта переменная, притом, что ее значение должно быть 
неопределено.</p></div>

<table width="100%" border="0" cellspacing="0" cellpadding="2">
 <tr>
  <td width=15%></td>
  <td><div align="justify"><p><i>Отказ от оператора FOR — другой пример разрыва древней 
традиции. Замысловатый механизм оператора FOR, принятый в языке Algol-60, был значительно 
упрощен в языке Паскаль (и в Modula-2). Незначительная практическая ценность этого 
оператора привела к тому, что в Обероне он отсутствует.</i></p>

<div align="right"><p>Niklaus Wirth. From Modula to Oberon (1988)</p></div>
</div>
</td>
 </tr>
</table>


<div align="justify"><p>В Обероне Вирт вначале пошел на радикальный шаг — принял решение вообще отказаться от использования 
цикла <b>FOR</b>, поскольку его легко могут заменить циклы <b>WHILE</b>, <b>REPEAT</b> и универсальный <b>LOOP</b> 
(точнее, остался от Modula-2, где он всегда был и прекрасно себя зарекомендовал). С его 
помощью реализовывать можно абсолютно любой цикл. Но в том-то и состоит принцип разумного 
минимализма (вспомните изречение Эйнштейна, вынесенное в эпиграф описания Оберона — оно 
там не просто так) — избыточность даже минималистскому языку не противопоказана. 
<b>WHILE</b> и <b>REPEAT</b> прекрасно дополняют друг друга, а <b>LOOP</b> служит для особых случаев. 
<b>FOR</b> проще всего реализовывать через <b>WHILE</b> с заведением явной переменной цикла 
(и всеми явными, а не скрытыми, проблемами, которые вытекают из ее применения за границами 
цикла).
</p>

<div align="justify">В языке Оберон-2 (и затем в Компонентном Паскале) цикл <b>FOR</b> был восстановлен в своих 
правах, оставаясь при этом сомнительным компромиссом удобства работы.</div>

<p>Важно отметить, что в новой книге “Programming in Oberon” (2004) Никлаус Вирт упоминает <b>FOR</b> 
как полноценный оператор языка Оберон. По всей видимости, консерватизм и сопротивление 
программистов были столь сильны, что Вирт вынужденно пошел на уступку:</p></div>

<table width="100%" border="0" cellspacing="0" cellpadding="2">
 <tr>
  <td width=15%></td>
  <td><div align="justify"><p><i>Рекомендуется, чтобы оператор FOR использовался только 
в простейших случаях, в частности, операнды выражения, определяющего диапазон значений переменной 
цикла, не должны изменяться внутри цикла. Кроме того, и сама переменная цикла не должна 
подвергаться модификации внутри цикла. Значение переменной цикла после завершения оператора 
FOR должно считаться неопределенным.</i></p>

<div align="right"><p>Niklaus Wirth. Programming in Oberon (2004)</p></div>
</div>
</td>
 </tr>
</table>


<br>
<p><b>9.&nbsp;Зачем из Оберона исключены вариантные записи?</b></p>

<div align="justify"><p>Функциональность вариантных записей, используемых в Паскале и 
Modula-2, сохраняется в Обероне за счет введения концепции расширяемых типов данных 
(type extensions), это уникальное отличие Оберона.</p>

Приведем пример:<br>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
 <tr>
  <td width="5%"></td> 
  <td><font size="3"><pre>T  = <b>RECORD</b> x, y: <b>INTEGER</b> <b>END</b>;
T0 = <b>RECORD</b> (T) z: <b>REAL</b> <b>END</b>;
T1 = <b>RECORD</b> (T) b: <b>BOOLEAN</b>; s: <b>CHAR</b> <b>END</b>;</pre></font></td>
 </tr>
</table>

<p>Это означает, что базовый тип T, содержащий поля x и y, имеет два производных типа 
(расширения, обогащения). T0 в итоге содержит поля x, y и z. Тип T1 — поля x,y, b, s.</p>

<p>Расширение типа действует как в отношении статических типов (на основе полей комбинированного 
типа — <b>RECORD</b>), так и динамических (на основе полей ссылочного типа — <b>POINTER</b>).</p>

<p>Если в языке оставлять вариантные записи (как избыточность по отношению к расширению типа), 
то это серьезное препятствие к реализации полноценного сборщика мусора.</p>
</div>

<table width="100%" border="0" cellspacing="0" cellpadding="2">
 <tr>
  <td width=15%></td>
  <td><div align="justify"><p><i>В системах, опирающихся на использование автоматической 
утилизации памяти (сборку мусора), вариантная запись является большим камнем преткновения. 
Работа с ней является сложной и нескладной. Попутно отметим, что объявление вариантной 
записи может содержать несколько взаимоисключающих вариантов на одном и том же уровне 
и что они могут быть вложенными. Практически невозможно использовать сборщик мусора в 
отношении вариантных записей без введения дополнительных ограничений.</i></p>

<div align="right"><p>Niklaus Wirth. Type Extensions (1988)</p></div>
</div>
</td>
 </tr>
</table>

<table width="100%" border="0" cellspacing="0" cellpadding="2">
 <tr>
  <td width=15%></td>
  <td><div align="justify"><p><i>
Концепция задуманной операционной системы потребовала высокодинамичного централизованного 
распределения памяти, операющегося на технологию сборки мусора. И хотя Modula-2 в 
принципе никак не препятствует встраиванию соответствующего сборщика мусора, наличие 
в языке вариантных записей создает серьезные препятствия. Поскольку новый механизм 
расширения типов сделал вариантные записи излишней возможностью, то логичным решением 
было попросту изъять этот ненужный элемент. Такой шаг привел к ограничению (подмножеству) 
языка Modula-2.</i></p>

<div align="right"><p>Niklaus Wirth. From Modula to Oberon (1988)
</p></div>
</div>
</td>
 </tr>
</table>

<br>
<p><b>10.&nbsp;Почему в Обероне нет обработки исключений?</b></p>

<div align="justify"><p>Для простой по своей архитектуре системы Oberon, которая была реализована на языке 
Оберон, опираясь на механизм команд (экспортируемые модулями процедуры без параметров), 
в этом не было необходимости. Это явилось первым побудительным мотивом отказаться от 
использования обработки исключений в языке Оберон.</p>

<p>Вторая причина состоит в том, что обработка исключений (exception handling), близкая 
по своей природе к оператору <b>goto</b> и программным прерываниям, является достаточно 
опасным средством, при этом потребность использования исключений острее всего проявляется 
в наиболее критичных задачах (системы реального времени).</p>

<p>Для них обработка исключений, как показал опыт использования предшественника 
Оберона — языка Modula-2, может быть эффективно вынесена на уровень библиотек. 
Результаты подобного исследования для обработки исключений в среде параллельных процессов 
были опубликованы в журнале Structured Programming (1993), в редколлегии которого были 
Дональд Кнут и Никлаус Вирт, группой отечественных специалистов из Московского 
авиационного института — это была первая публикация советских ученых в столь авторитетном 
издании. См. I.Egorov, R.Bogatyrev, D.Petrovichev. <a href="http://www.oberon2005.ru/paper/m2ex.pdf">Yet Another Approach to Modula-2 
Implementation of Exception Handling Mechanism</a> // Structured Programming, 1993, #14(1), 
pp. 23-36.</p>

<p>Другой подход был предложен проф. Ханспетером Мёссенбёком, автором языка Оберон-2, и его 
коллегами из Университета в Линце им. Кеплера (Австрия). См. Markus Hof, Hanspeter 
Mossenbock, Peter Pirkelbauer. <a href="http://www.oberon2005.ru/paper/p_ex.pdf">Zero Overhead Exception Handling Using Metaprogramming</a> 
// 1996.</p></div>

<br>
<p><b>11.&nbsp;Чем принципиально отличается поддержка ООП в Обероне от ее воплощения в ведущих промышленных языках?</b></p>

Если сформулировать коротко, то

<ul>
<li>Модули (module) и расширения типа (type extension) против концепции классов (class) и пространств имен (namespace).</li>
<li>Процедурные переменные против процедурных констант.</li>
<li>Подход с акцентом на экземпляры (instance-centred approach) против подхода с акцентом на классы (class-centred approach)</li>
</ul>

<table width="100%" border="0" cellspacing="0" cellpadding="2">
 <tr>
  <td width=15%></td>
  <td><div align="justify"><p><i>
Механизм классов предусматривает, что все процедуры, применимые к объектам класса, будут 
определены вместе с описанием данных. Эта догма проистекает из понятия абстрактного 
типа данных, но она служит серьезным препятствием при разработке больших систем, где крайне 
желательна возможность добавить новые процедуры, определенные в дополнительных модулях. 
Очень неудобно обязательно переопределять класс только лишь потому, что какой-то метод 
(процедура) должен быть добавлен или изменен, в особенности когда это изменение требует 
перекомпиляции описания класса и всех его клиентных модулей.</i></p>

<div align="right"><p>Niklaus Wirth. From Modula to Oberon (1988)
</p></div>
</div>
</td>
 </tr>
</table>

<table width="100%" border="0" cellspacing="0" cellpadding="2">
 <tr>
  <td width=15%></td>
  <td><div align="justify"><p><i>
Объявление класса в объектно-ориентированных языках выглядит подобно объявлению записи 
с дополнительными объявлениями процедур (или их заголовков). Такой подход обладает 
некоторыми достоинствами и ведет к определенным последствиям. В языках Modula-2 и Оберон 
соответствующее поле процедурного типа предполагает особую роль переменной и, следовательно, 
фактическая процедура должна присваиваться этой переменной явно всякий раз, когда 
порождается новый экземпляр записи. Это можно рассматривать либо как нагрузку 
(и как источник ошибок), либо как дополнительную степень свободы (и мощи). К тому же 
большинство типичных приложений привязывает одну и ту же процедуру (обработчик) ко всем 
экземплярам класса: взгляд с позиции методов ориентирован на классы; взгляд с позиции 
Оберона — на экземпляры.
<br><br>
<...>
<br><br>
Различия между подходами с акцентом на классы (class-centred) и с акцентом на экземпляры 
(instance-centred) по отношению к описанию методов можно рассмотреть под другим углом. 
В первом случае методы объявляются как (процедурные) константы, во втором — как (процедурные) 
переменные. Ограниченные возможности первого подхода уже проявились в отношении подклассов, 
т.е. расширений типов. Обычно подкласс делает методы отличными от методов своего 
суперкласса.

И так как методы задаются в виде констант, вызывается новая реализация, которая 
переопределяет описание суперкласса. В соответствующих реализациях переопределение 
(перегрузка) осуществляется за счет выделения своей таблицы методов для каждого подкласса. 
В ориентированном на экземпляры подходе языка Оберон не требуется ни подобный 
дополнительный механизм, ни дополнительная символика переопределения, так как все это 
достигается через обычное явное присваивание.
<br><br>
<...>
<br><br>
Как результат, Оберон концептуально проще, и его реализации не нагружаются дополнительными 
механизмами работы с классами. С другой стороны, объектно-ориентированные языки могут 
предоставлять несколько более удобную символику и обеспечивать безопасность за счет 
гарантии неизменности объявленных методов для всех экземпляров класса, что выражается 
в улучшенной эффективности отложенных вызовов. Правда, это стоит рассматривать как 
незначительное преимущество, поскольку есть уверенность в том, что использование 
объектно-ориентированной парадигмы должно быть осознанным и там, где это в самом деле 
нужно. При проектировании операционной системы [Oberon] мы обнаружили, что практически 
вся система была успешно запрограммирована в традиционном стиле, а объектно-ориентированный 
стиль затронул лишь систему визуализаторов, которая предоставляла распределенное 
управление.</i></p>

<div align="right"><p>Niklaus Wirth, Modula-2 and Object-Oriented Programming (1990)
</p></div>
</div>
</td>
 </tr>
</table>

<div align="justify"><p>Детали подхода Вирта к поддержке ООП в Обероне изложены в его новой книге “Programming 
in Oberon” (October 2004), в 4-й главе, посвященной ООП.</p>

<p>В родоначальнике ООП, языке Simula, использовались поля данных (прообраз комбинированного 
типа <b>record</b> языка Паскаль), но не было понятия методов (они появились в Smalltalk) — 
поведенческим аспектом класса занималась сопрограмма (coroutine).</p>

<p>Сопрограмма была положена в основу квазипараллелизма языка Modula-2, но в Обероне этот 
механизм не используется (вынесен за пределы языка).</p>

<p>Оберон предлагает использовать схему, близкую Simula: вместо набора методов, реализуемых 
через поля процедурного типа (т.е. коммутаторов процедур) заводится одна выделенная 
процедура-обработчик (handler). Она имеет два параметра: объект, к которому применяется, 
и сообщение (message). Сообщение выражается в виде расширяемого комбинируемого типа 
(<b>RECORD</b>), это определяет протокол класса. Подобный подход показал свою эффективность 
и наглядность при реализации системы Oberon (1985—1995).</p>

<p>При таком подходе объект (object) представляется указателем на запись. Запись содержит 
всего одно поле процедурного типа — handle. При инициализации (порождении объекта) этому 
полю явно присваивается процедура-обработчик, которая в точности удовлетворяет 
спецификации процедурного типа по набору формальных параметров процедуры. Обработчик 
имеет два параметра: объект-адресат и сообщение. Сообщение определяется то действие, 
которое требуется применить по отношению к объекту-адресату сообщения. Обработчик создается 
из коммутатора сообщений, реализуемого через выделенный условный оператор <b>IF-ELSIF-END</b>. 
Сообщения могут отправляться в режиме широковещательной рассылки всем объектам с разнородной 
структурой данных без знания характера этой структуры. Неприемлемые сообщения будут просто 
игнорироваться.</p></div>

<br>
<p><b>12.&nbsp;Что такое модуль в понимании Оберона и чем модульное программирование помимо
 отсутствия полиморфизма и наследования отличается от ООП?</b></p>

<div align="justify"><p>Расширенный ответ на этот вопрос можно найти в статье Р.Богатырев <a href="http://www.oberon2005.ru/qa191005.html">"Модульное программирование: 
Terra Incognita"</a> (2005).</p></div>
<br>
<p><b>13.&nbsp;Почему в Обероне нет ничего подобного P-коду? Его ведь создал Вирт, а идеи использовались 
потом в Java и .NET.</b>

<div align="justify"><p>Для обеспечения мобильности кода нет никакой необходимости в реализации виртуальных машин, подобных 
Java VM. Проект Оберон наглядно доказал, что более эффективен и перспективен подход кодогенерации на лету, 
когда генерация машинного кода из компактного промежуточного представления, полученного после компиляции, 
осуществляется самим загрузчиком с конкретизацией под определенную аппаратную платформу. Этот подход 
был разработан Микаэлем Францем (Michael Franz), аспирантом Никлауса Вирта, защитившим 
на эту тему диссертацию в 1994 г. в ETH Zurich.
</p>
<p>Более подробно ответ на этот вопрос можно найти в работе Р.Богатырев <a href="http://www.oberon2005.ru/qa141005.html">"Оберон и виртуальная машина"</a> (2005).</p>
</div>


<br><br>
<div align="justify"><p><b>Примечание.</b> Особенности языка Оберон раскрыты в официальном описании N.Wirth <a href="http://www.oberon2005.ru/paper/oberon.pdf">"The Programming Language Oberon"</a> (October 1990) 
и в работе Р.Богатырев <a href="http://www.oberon2005.ru/paper/obe_exp.pdf">"Язык Оберон. Краткий путеводитель"</a> (2005).
</p>
</div>
<div align="right"><p><a href="/rb.html">Р.Б.</a></p></div>

  </td>
  <td class="news" valign="top">
  <p><strong>Города:</strong></p>
  <b>O</b>&nbsp;&nbsp;<font color="#6B6B6B">(13 сентября)</font>&nbsp;&nbsp;С.-Петербург 
  <br><b>B</b>&nbsp;&nbsp;<font color="#6B6B6B">(19 сентября)</font>&nbsp;&nbsp;Москва 
  <br><b>E</b>&nbsp;&nbsp;<font color="#6B6B6B">(26 сентября)</font>&nbsp;&nbsp;Нижний Новгород
  <br><b>R</b>&nbsp;&nbsp;<font color="#6B6B6B">(29 сентября)</font>&nbsp;&nbsp;Екатеринбург
  <br><b>O</b>&nbsp;&nbsp;<font color="#6B6B6B">(2 октября)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Новосибирск 
  <br><b>N</b>&nbsp;&nbsp;<font color="#6B6B6B">(5 октября)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Томск 
  
  <br><br>
   <p><strong>Информационные ресурсы:</strong></p>
  <ul>
  <li><a href="http://www.inr.ac.ru/~info21/" target="_blank">Проект 'Информатика-21'</a></li>
  <li><a href="http://www.delphikingdom.ru/" target="_blank">Королевство Delphi</a></li>
  <li><a href="http://www.uni-vologda.ac.ru/oberon/index.html" target="_blank">Оберон. Первый сайт</a></li>
  <li><a href="http://www.delphikingdom.ru/asp/talktopic.asp?ID=285" target="_blank">Форум 'Мысли об Обероне'</a></li>
  <li><a href="http://www.oberon.ethz.ch" target="_blank">ETH Oberon</a></li>
  <li><a href="http://www.modulaware.com/mdltr_.htm" target="_blank">The ModulaTor Journal</a></li>
  <li><a href="http://www.cs.inf.ethz.ch/~wirth/" target="_blank">Niklaus Wirth. Personal Page</a></li>  
  <li><a href="http://en.wikipedia.org/wiki/Niklaus_Wirth" target="_blank">Niklaus Wirth. Wikipedia</a></li>  
  <li><a href="http://www.adeptis.ru/vinci/m_part7_2.html" target="_blank">Niklaus Wirth. Photos</a></li>  
  <li><a href="http://search.barnesandnoble.com/booksearch/results.asp?WRD=Niklaus+Wirth" target="_blank">Niklaus Wirth. Books</a></li>  
  </ul>
  <br>
  <p><strong>Книги Вирта:</strong></p>
  <ul>
  <li><a href="/book/pio2004.pdf">Programming in Oberon (2004)</a></li>
  <li><a href="/book/ads2004.pdf">Algorithms and Data Structures (2004)</a></li>
  <li><a href="/book/po1992.pdf">Project Oberon (1992)</a></li>
  <li><a href="/book/pio1992r.pdf">Oberon. Reiser (1992)</a></li>  
  </ul>
  <br>
  <p><a href="tools.html"><strong>Языки Оберон-семейства:</strong></a></p>
  <ul>
  <li><a href="/paper/oberon.pdf">Oberon (1988-1990)</a></li>
  <li><a href="/paper/oberon-2.pdf">Oberon-2 (1991-1995)</a></li>
  <li><a href="/paper/cp.pdf">Component Pascal (1997-2001)</a></li>
  <li><a href="/paper/act_obe.pdf">Active Oberon (2000-2004)</a></li>  
  <li><a href="/paper/znn.pdf">Zonnon (2003-2005)</a></li>
  </ul>
  <br>
  <p><a href="tools.html"><strong>Инструментарий:</strong></a></p>
  <ul>
  <li><a href="http://www.oberon.ch/blackbox.html" target="_blank">BlackBox [Oberon microsys.]</a></li>
  <li><a href="http://www.inr.ac.ru/~info21/install/welcome.html" target="_blank">BlackBox Russian</a></li>
  <li><a href="http://www.excelsior-usa.com/xds.html" target="_blank">XDS [Excelsior]</a></li>
  <li><a href="http://www.plas.fit.qut.edu.au/gpcp" target="_blank">GPCP JVM/.NET [QUT]</a></li>
  <li><a href="http://www.uni-vologda.ac.ru/~c3c/" target="_blank">JOB [С.Свердлов]</a></li>
  <li><a href="http://ooc.sourceforge.net/" target="_blank">OO2C [sourceforge]</a></li>
  <li><a href="http://www.bluebottle.ethz.ch/" target="_blank">Active Oberon [ETH]</a></li>
  <li><a href="http://www.zonnon.ethz.ch/" target="_blank">Zonnon [ETH]</a></li>
  <li><a href="http://www.zinnamturm.de/" target="_blank">Component Pascal Collection</a></li>
  <li><a href="http://www.modula2.org/" target="_blank">Modula2.org</a></li>
  <li><a href="http://www.modulaware.com/m2wr/?ring=modula2&id=1&m=hub" target="_blank">Modula-2 WebRing</a></li>
  <li><a href="http://v.webring.com/hub?ring=oberon" target="_blank">Oberon-2 WebRing</a></li>
  </ul>
  <br>
  <p><strong>Координаторы турне:</strong></p>
  <ul>
  <li><a href="http://www.osp.ru/pcworld/about/" target="_blank">Р.П.Богатырев (Мир ПК)</a></li>
  <li><a href="http://www.inr.ac.ru/~ftkachov/claims.htm" target="_blank">Ф.В.Ткачев (Институт ядерных исследований РАН)</a></li>
  <li><a href="http://www.inf.ethz.ch/personal/zueff/" target="_blank">Е.А.Зуев (ETH)</a></li>
  <li><a href="http://www.jg.inf.ethz.ch/wiki/JG/Front" target="_blank">Проф. Ю.Гуткнехт (ETH)</a></li>
  <li><a href="http://www.suhomlin.ru/" target="_blank">Проф. В.А.Сухомлин (МГУ)</a></li>
  <li><a href="http://ict.edu.ru/persons/index.php?a=pers&c=getForm&r=persDesc&d=light&id_pers=13" target="_blank">Проф. А.А.Шалыто (ИТМО)</a></li>
  <li><a href="http://www.software.unn.ac.ru/?dir=17" target="_blank">Проф. В.П.Гергель (ННГУ)</a></li>
  </ul>  </td>
 </tr>
</tbody></table></td>
 </tr>
</tbody></table>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
 <tbody><tr>
  <td><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><table border="0" cellpadding="0" cellspacing="0" height="10" width="1"><tbody><tr><td></td></tr></tbody></table></td></tr></tbody></table></td>
 </tr>
</tbody></table>
<p>
</p>

<table border="0" cellpadding="5" cellspacing="0" width="100%">
 <tbody><tr>
  <td class="footer" valign="top" width="80%"><p><b>Организаторы турне:</b> 
  <a href="http://www.pcworld.ru/" target="_blank">Мир ПК</a>, 
  <a href="http://www.inr.ac.ru/~info21/" target="_blank">Информатика-21</a>,
  <a href="http://www.inf.ethz.ch/" target="_blank">ETH Zurich</a>, 
  <a href="http://2005.edu-it.ru/" target="_blank">МГУ</a>, 
  <a href="http://www.ifmo.ru/" target="_blank">ИТМО</a>, 
  <a href="http://www.unn.ru/" target="_blank">ННГУ</a>, 
  <a href="http://www.russoft.ru/index_r.php" target="_blank">РУССОФТ</a>, 
  <a href="http://www.microsoft.com/rus/" target="_blank">Microsoft Russia</a>, 
  <a href="http://www.borland.ru/" target="_blank">Borland</a></p>
</td>
  <td class="footer" align="right" valign="top"><a href="mailto:wirth2005@mail.ru">Контакты</a>
  <p>
  </p>
  </td>
 </tr>
</tbody></table>



</body></html>