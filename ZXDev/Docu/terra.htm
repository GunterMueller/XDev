<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Oberon2005.ru</title>
  
<link rel="StyleSheet" type="text/css" href="f01style.css">
<style>

h1 {color: #f0f0f0; font:bold 180% arial,sans-serif;}


body, td {font-family: Arial, Geneva CY, Sans-Serif; font-size: 80%;}
.header {background-color:#006699}
.footer {background-color:#f0f5ff}
.also {font:80%; background:#f0f0f0;}
.also2 {font:80%; background:#efefef;}
.news {font:80%;background:#ffffff;}

.softbg {background:#DDDDDD;}
.clear {background:#ffffff;}

.force {
  letter-spacing: 0.1em;
  margin-left: 0.2em;
  margin-right: 0.2em;
}

</style></head>


<body topmargin="0" bgcolor="#ffffff" marginheight="0">
<table border="0" cellpadding="5" cellspacing="0" width="100%">
 <tbody><tr>
  <td class="header" colspan="2"><a href="http://www.oberon2005.ru/" class="header"><div align="center">Никлаус&nbsp;Вирт&nbsp;&nbsp;в&nbsp;&nbsp;России<br>Niklaus&nbsp;Wirth&nbsp;&nbsp;in&nbsp;&nbsp;Russia</div></a></td>
 </tr>
</tbody></table>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
 <tbody><tr>
  <td><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><table border="0" cellpadding="0" cellspacing="0" height="10" width="1"><tbody><tr><td></td></tr></tbody></table></td></tr></tbody></table></td>
 </tr>
</tbody></table>


<table border="0" cellpadding="0" cellspacing="0" width="100%">
 <tbody><tr>
  <td class="softbg"><table border="0" cellpadding="8" cellspacing="1" width="100%">
 <tbody><tr>
  <td class="softbg" width="75%"><strong><a href="http://www.oberon2005.ru/">Главная страница</a>
    &nbsp;/&nbsp;
    
    Оберон. Вопросы и ответы
    
    </strong></td>
  <td class="softbg" width="25%"><strong>БОЛЬШОЕ ТУРНЕ&nbsp;&nbsp;Н.&nbsp;ВИРТА</strong></td>
 </tr>
 <tr>
  <td class="clear" valign="top">
<p><font color=#0000FF size=4><strong>Модульное программирование: Terra Incognita
</strong></font><br>

<div align="justify"><p>Исторически сложилось так, что <i>модульное программирование</i> (modular programming) в своем 
классическом понимании оказалось для большинства программистов-практиков землей 
неизведанной, terra incognita. Из ведущих языков программирования (в порядке популярности 
— Cи, Java, C++, Visual Basic, Delphi, C#, см. Р.Богатырев <a href="http://www.oberon2005.ru/rb/rb0501b.pdf" target="_blank">"Популярность 
языков программирования"</a>), пожалуй, только Delphi (со времен Turbo Pascal 4.x) имеет 
средства (unit), отдаленно приближенные к классике. Концепция модуля, кстати, отсутствует 
в таких известных языках, как Smalltalk-80 и Eiffel.</p>

<p>Как же так произошло? Дело в том, что доминирующая сейчас ветвь языков Си-семейства 
(Cи, C++, Java, C#) не опиралась на эту концепцию, вытеснив ее в конце 1980-х годов 
другой, возведенной в разряд абсолюта — <i>объектно-ориентированным программированием</i> (ООП).</p>

<p>Если говорить коротко, то ООП опирается на идею совмещения в концепции <i>класса</i> (class) 
понятий <i>модуля</i> (module), <i>типа</i> (type) и <i>механизма расширения</i> (extension; 
наследования, обогащения). При этом в рамках ООП на основе классов непросто добиться 
полноценного воплощения возможностей триады <i>"модуль-тип-расширение"</i>, исповедуемой, в 
частности,  языками Оберон-семейства. Приходится добавлять понятие пространства имен 
(namespace), охватывающее вместо одного несколько файлов, да еще и с поддержкой вложенности, 
вводить вместо понятного механизма экспорта-импорта запутанный набор средств по разграничению 
областей видимости (public, private, friend, protected и т.п.).  Детальнее об этих проблемах см. в статье 
С.Свердлов <a href="http://www.pcweek.ru/?ID=65948" target="_Blank">"Язык программирования 
Си#: критическая оценка"</a>. Помимо <i>области видимости</i> в сфере языков программирования 
имеется и такое важное понятие, как <i>область существования</i>. А с ней чехарда не меньшая. 
</p>
<p>Появление понятия <i>компонента</i> (component), точнее, возрождение этого понятия на новом витке 
эволюции программирования в середине-конце 1990-х годов, остро поставило вопрос корректного 
отображения виртуально-мифического понимания классов на реально-осязаемое восприятие 
компонентов. Худо-бедно, в языках промышленного программирования, исповедующих диктатуру 
классов, задача решается, но весь вопрос в том, зачем это делать в подавляющем большинстве 
случаев таким неестественным образом? Само простое и логичное — отождествить физическое и 
отчуждаемое представление модулей с понятием компонента.</p>

<div align="justify"><p>Модуль можно сравнить с устройством, имеющим средства сопряжения (подключения), через 
которые и происходит как управление самим устройством, так и обмен данными. Это своего рода 
черный ящик, для которого экспорт и импорт определяют его интерфейс и зависимость от других 
устройств.
</p></div>
<p>Принципиальное отличие модулей от классов: <i>модули</i> — это уникальные экземпляры (второго 
такого в системе нет), не допускающие обобщения (generic-модули здесь не рассматриваем, 
они находятся вне подхода Вирта и в его языках не поддерживаются). Т.е. на их основе 
ничего порождать нельзя. Это важно. </p>

<p>Модули не только определяют четкие синтаксические границы кода (процедур) и данных, но 
также являются <i>единицами этапа компиляции</i> (unit of compilation) и <i>единицами этапа 
загрузки</i> (а также выполнения, замены — unit of replacement). Эти единицы можно 
редактировать, документировать, распространять и компилировать по отдельности. 
В модульном программировании связывание происходит на этапе загрузки (<i>динамическое 
связывание</i>, dynamic linking) и абсолютно невидимо пользователю.</p>

<p>Модуль — это контейнер для набора объектов, при этом он является средством абстрагирования 
кода и данных, ибо имеет две части: интерфейс и реализацию. Целостность данных и их 
защита обеспечивается в модулях за счет информационного сокрытия (information hiding, иногда путают с инкапсуляцией) и 
физического вычленения данных и кода из создаваемой системы (программы). Причем при 
сочленении модулей гарантируется соблюдение всех требований безопасности типов 
(type safety).</p>

<p>Интерфейс в модульном программировании рассматривается как жесткая спецификация, контракт, 
который должен неукоснительно соблюдаться клиентами модуля (импортирующими его) и 
реализацией данного модуля (или несколькими альтернативными реализациями). Любое 
изменение контракта требует перекомпиляции всех зависимых модулей. Важно отметить, что компилятор 
Оберона в системе ETH Oberon поддерживает режим расширения интерфейса, когда чистое расширение 
(добавление процедур) не влияет на ранее оттранслированные модули. В этом случае создается расширение 
бинарного представления интерфейса (символьного файла), что позволяет подстыковывать расширенную версию модуля 
без перекомпиляции ранее оттранслированных клиентских модулей.</p>

<p>Для модульного программирования характерно использование <i>раздельной компиляции</i> (separate compilation, 
см. R.Crelier <a href="http://www.oberon2005.ru/paper/eth10650.pdf" target="_blank">"Separate 
Compilation and Module Extension"</a>), когда компиляция интерфейса и реализации модуля 
делается отдельно от реализации других модулей, но с обязательным участием интерфейсов 
всех прямо и косвенно импортируемых модулей. Если нет возможности отделить интерфейс в текстовом или бинарном виде 
от реализации модуля, то такую систему программирования нельзя считать системой раздельной компиляции, ибо нарушается главный принцип — 
компиляции модуля при отсутствии в пределах досягаемости компилятора реализаций импортируемых им модулей.</p>

<p>Все ошибки несостыковки обнаруживаются на 
этапе трансляции (причем даже до реализации других модулей, ведь нужны только 
контракты-интерфейсы).  Более примитивная и распространенная схема <i>независимой 
компиляции </i>(independent compilation) не использует эту информацию и вынуждена 
заниматься выявлением расхождений в сопряжении файлов лишь на этапе компоновки 
(linking). Высокая гибкость в модульном программировании достигается за счет совмещения 
фазы компоновки и загрузки. А в некоторых случаях (реализация Оберона на уровне подхода 
Oberon Module Interchange, предложенного Микаэлем Францем в 1994 г., см. <a href="http://www.oberon2005.ru/paper/obe_java3.pdf" target="_blank">"Динамическая 
кодогенерация: ключ к разработке переносимого ПО"</a>) совмещается на этом этапе (перед 
компоновкой) и фаза генерирования машинного кода для конкретной целевой архитектуры. Т.е. 
<i>безо всякой виртуальной машины</i> достигается эффективное выполнение модулей на 
любой операционной платформе.</p>

<p>В отношении области существования и области видимости. Процедура (а также объявленные в 
ней данные) существует ровно то время, пока не произойдет возврат из нее в точку ее вызова, 
и имеет абсолютно прозрачную по импорту и непрозрачную по экспорту область видимости (одностороннюю). 
Модуль (и его данные) существует все то время, пока загружен в память. Область его 
видимости регулируется средствами явного экспорта-импорта идентификаторов (импорта 
модулей; экспорта процедур, типов, констант, переменных, отдельных полей составных переменных). </p>

<p>Инициализация всех модулей, затрагиваемых данной программой, производится в порядке, 
обратном их глубине зависимости по импорту. Другими словами, перед началом работы 
программы производится т.н. топологическая сортировка, которая позволяет выявить  
последовательность проведения инициализации в направлении от абсолютно независимых 
по импорту модулей к максимально зависимым (а самым зависимым является, естественно, 
программный модуль — MODULE, т.е. программа).</p>

<p>Модуль на уровне своего содержимого устанавливает важный принцип <i>No Paranoia Rule</i> (никакой 
паранойи, см. Clemens Szyperski <a href="http://www.oberon2005.ru/paper/p_modcla.pdf" target="_blank">"Import 
is Not Inheritance. Why We Need Both: Modules and Classes"</a>). Иными словами, внутри 
одного модуля можно размещать несколько классов, при этом общение между их полями и 
методами абсолютно прозрачно внутри, тогда как снаружи может регулироваться средствами 
избирательного экспорта (т.е. спецификаторами экспорта). Схема размещения в одном модуле 
строго одного класса практически соответствует общепринятой модели ООП. Иными словами, 
программист волен выбирать степень концентрации нескольких классов в одном модуле. 
Это важное преимущество Оберона (1988) по сравнению с другими языками ООП.
</p>
<p>В языке Modula-2 (1979) для получения возможноcтей тонкого управления экспортом-импортом 
на локальном уровне (в рамках программных и исполнительных модулей) Вирт ввел понятие 
локального модуля. Однако практика показала, что это излишний и запутанный механизм, 
который в Обероне был уже исключен.</p>

<p>Если продолжать разговор о Modula-2 (как прямом предшественнике Оберона), то здесь есть 
тонкий момент. Это разная трактовка терминов <i>definition</i> (описание) и <i>declaration</i> 
(объявление, определение). Аналогично и для глаголов: define — описывать, declare — 
объявлять, определять. Definition подразумевает экспорт, соответственно, и информацию 
там требуется приводить ровно в том объеме, которая необходима для реализации принципов 
сокрытия информации. Описание может доопределяться, а объявление (определение) носит 
законченный характер. Но объявление можно расширять (или обогащать, удачный термин 
проф. В.Ш.Кауфмана из МГУ), напр., как это делается в языках Оберон-семейства. Если следовать 
такой терминологии, то в Обероне, в отличие от Modula-2, нет надобности делать описания. 
Достаточно использовать только объявления, в которых помечать звездочками (спецификаторами 
экспорта) те элементы, которые и должны быть видны снаружи, т.е. должны сформировать 
описание.</p>

<p>В языке Modula-2 различие между описанием и объявлением (определением) прослеживается 
на уровне DEFINITION MODULE (описательный модуль) и IMPLEMENTATION MODULE (исполнительный 
модуль). В описательном модуле можно не только давать <i>описание</i> (скрытых типов, процедур), 
но и приводить <i>объявление</i> (типов, констант, переменных, но не процедур!).  К одному 
описанию (definition) можно готовить несколько разных реализаций (implementation) и 
подменять их (на этапе компоновки) в зависимости от требований (точности вычислений, 
быстродействия, особенностей алгоритма и т.п.)
</p>
<p>В Modula-2 допускался циклический импорт на уровне DEFINITION (не страшно, ибо это просто 
ссылающиеся друг на друга описания), но запрещался на уровне IMPLEMENTATION. В Обероне 
эта проблема отпала сама собой. Здесь из-за текстуального слияния интерфейса и реализации, 
а также для предотвращения ненужных проблем циклический импорт запрещен.</p>

<p>В Обероне сохранилось деление на описательный (интерфейсный) и исполнительный модули с 
той принципиальной разницей, что описательный модуль готовится теперь уже не 
проектировщиком (программистом), как в Modula-2, а автоматически формируется компилятором из 
исполнительного модуля на основе спецификаторов экспорта (звездочек у 
каждого экспортируемого объекта, включая отдельные поля записей). Относительным 
неудобством стала необходимость для получения спецификации (интерфейса) фиктивной 
(вырожденной) реализации модуля. Зато во всем остальном были весьма элегантно решены 
проблемы модульного программирования. </p>

<p>Очень важная особенность Оберона — использование исключительно квалифицирующего импорта 
(тогда как в Modula-2 допускался и неквалифицирующий), т.е. помимо указания модуля в 
списке импорта данного модуля в самом тексте импортирующего модуля каждый импортируемый 
объект указывается с явным префиксом имени модуля, например, IMPORT Math; ... Math.sin(x), 
где Math — это модуль, реализующий базовые математические функции. В Обероне был введен 
механизм синонимизации имен, когда на уровне списка импорта можно задать соответствие 
внешнего имени модуля его локальному синониму (что удобно для исключения коллизиций и 
для явной коммутации модулей).</p>

<p>В Обероне появилось еще одно интересное решение, связанное с модульным программированием. 
Понятие программы исчезло. Вместо этого Вирт ввел концепцию <i>команд</i> (command). Команды — 
это экспортируемые процедуры без параметров, определяющие точки входа (вызова) программы. 
Другими словами, программа превратилась в модуль, экспортирующий по сути сервисы. В ОС 
Oberon команды становятся полноправными командами операционной системы, которые можно 
напрямую запускать, связывать в  последовательность обработки и т.п. Любые модули 
(библиотечные и программные — разницы между ними нет) можно динамически загружать и 
выгружать (без перекомпиляции).</p>

<p>Чтобы детальнее разобраться в природе модульного программирования, давайте обратимся к 
истории. </p>

<p>До начала 1970-х годов программы создавались в виде монолитных блоков, либо делались из 
независимых частей, сопряжение которых было достаточно примитивным — на уровне вызовов 
подпрограмм (процедур). Отсюда и пошли два известных понятия — <i>цельная компиляция</i> 
(whole compilation) и <i>независимая компиляция</i> (independent compilation). Первый случай 
простой и пояснений наверняка не требует (транслируется вся программа целиком). Во втором 
каждый блок (файл) транслируется отдельно, фактически без наличия информации о точках 
сопряжения. Все проблемы увязки возлагались на <i>компоновщик</i> (linker). Именно он 
состыковывал оттранслированные части, соединял программу с библиотеками, которые та 
использовала.</p>

<p>Лобовое решение этой проблемы нашло свое отражение в языке Cи в виде знаменитых директив 
препроцессора (#include). Здесь проблема не решалась, а запрятывалась вглубь. Вместо 
строгого контроля и четкого взаимодействия механизмов экспорта-импорта, выделения 
областей видимости и существования предлагалось использовать сокращенную запись 
операций скрытого расширения исходного текста на этапе, непосредственно предшествующем 
компиляции (препроцессинга).</p>

<p>Не буду вдаваться в подробности относительно проблем #include, унаследованных другими 
языками Си-семейства, особенно C++. Об этом написано предостаточно. См. напр., Питер 
Мойлан <a href="http://www.oberon2005.ru/paper/arg_vs_c.pdf" target="_blank">"Аргументы 
против Си"</a>, M. Sakkinen <a href="http://www.oberon2005.ru/paper/ms1993.pdf" target="_blank">"The 
Darker Side of C++"</a>, I.Joyner <a href="http://www.oberon2005.ru/paper/joyner96.pdf" target="_blank">"A 
Critique of C++ and Programming and Language Trends of the 1990s"</a>.</p>

<p>В каноническом Паскале (в трактовке Вирта) данный вопрос вообще никак не решался, и это 
было безусловно ахиллесовой пятой языка. Но в конце 1970-х годов сразу три языка включили 
в свой арсенал эффективный механизм модуля. Это сделали CLU (1973, Барбара Лисков, 
Массачусетский технологический институт, США) — понятие <i>кластера</i> (cluster), Modula-2 
(1979, Никлаус Вирт, ETH Zurich) — понятие <i>модуля</i> (module) и Ada (Джин Ихбиа и др., 1980, 
Министерство обороны США) — понятие пакета (package).</p>

<p>Однако, пожалуй, первым наиболее явно это сделал язык Mesa (1973, Джеймс Митчелл и др., 
Xerox PARC), — язык, положенный Виртом в основу Modula (1976), а потом и Modula-2 (1979) 
после года работы Вирта (1976—1977) в стенах Xerox PARC.</p>

<p>Всей этой четверке языков предшествовали научные исследования, отчеты о которых выходили 
в очень компактный промежуток времени (1971-1974).</p>

<p>Сначала в апреле 1971 г. в Communications of the ACM появилась статья Никлауса Вирта из 
Высшей политехнической школы ETH (Швейцария) "Разработка программ методом пошагового 
уточнения" (Niklaus Wirth <a href="http://www.oberon2005.ru/paper/nw1971.pdf" target="_blank">"Program 
Development by Stepwise Refinement"</a>. В ней не использовалось слово "модуль", но 
при этом на примере классической задачи по расстановке 8 ферзей на шахматной доске были 
сформулированы подходы к декомпозиции (разбиению) монолитной программы на набор задач 
(действий, инструкций), каждая из которых при очередном шаге уточнения получает все более 
высокую степень конкретизации, при этом затрагивая конкретизацию и данных. Это устанавливало 
иерархию абстракций на уровне операций и данных.</p>

<p>В декабре 1972 г. в Communications of the ACM была опубликована статья Дэвида Парнаса 
из университета Карнеги-Меллон "О критериях по декомпозиции систем на модули" (David 
Parnas <a href="http://www.acm.org/classics/may96/" target="_blank">"On the Criteria 
To Be Used in Decomposing Systems into Modules"</a>).</p>

<p>Помимо собственно декомпозиции системы важным критерием модуляризации Парнас назвал 
сокрытие информации (information hiding, "скрывать решение от других"). За счет 
использования средств внешних модулей (слова "использует", "зависит от") формируется 
иерархическая структура, которая задает отношение частичного порядка, подразумевающего 
проведение топологической сортировки.</p>

<p>В работе <a href="http://www.oberon2005.ru/paper/mit561.pdf" target="_blank">"A History 
of CLU"</a> Барбара Лисков (Barbara Liskov) из Массачусетского технологического института 
вспоминает: "В 1972 г. я предложила идею <i>разделов</i> (partitions). Система делится на иерархию 
разделов, каждый из которых представляет один уровень абстракции и состоит из одной или 
нескольких функций, оперирующих общими ресурсами… Связь на уровне данных между разделами 
ограничена использованием явных аргументов, передаваемых из функций одного раздела во 
(внешние) функции другого раздела. Неявное взаимодействие с общими данными осуществляется 
только среди функций, лежащих внутри соответствующего раздела…"</p>

<p>Далее она продолжает: "Это привело меня к пониманию связывания модулей с типами данных и 
к идее <i>абстрактных типов</i>, имеющих "слияние" данных с операциями по их обработке (это и есть инкапсуляция, encapsulation), которые могут 
быть использованы для доступа и манипулирования объектами… Я называла типы <i>абстрактными</i>, 
поскольку они не предоставляются напрямую языком программирования, а вместо этого должны 
реализовываться пользователем. Абстрактный тип является абстрактным точно в таком же смысле, 
как то, что процедура является абстрактной операцией".</p>

<p>В начале 1973 г. Барбара Лисков на фоне разочарования работами по методологии 
программирования и зачатками модульного программирования в развитие идеи разделов создала 
новую концепцию — кластер (cluster), что и привело к образованию нового языка — CLU.</p>

<p>Концепция модуля как основы сокрытия информации (information hiding) тесно переплелась 
с концепцией абстрактных типов данных (ADT, abstract data types), поскольку введение 
различных уровней абстракции и обеспечивалось средствами контроля областей видимости 
со стороны модуля.</p>

<p>В октябре 1974 г. вышла известная статья Тони Хоара <a href="http://www.oberon2005.ru/paper/th1974.pdf" target=_blank>"Monitor: 
An Operating System Structuring Concept"</a>. Годом ранее в работе "Operating System Principles" 
Пер Бринч Хансен ввел аналогичное понятие <i>"shared"</i>. Впоследствии этой идее дали название 
<i>мониторы Хансена-Хоара</i>. Это особая форма модуля, в который заключены процедуры и 
соответствующие структуры данных, при этом доступ к модулю (его процедурам) для внешних 
процессов является взаимоисключающим.</p>

<p>Итак, к середине 1970-х годов понятие модуля стало обретать все более ясные очертания, при 
этом сформировались две специфики его применения — мультипрограммирование (монитор) и 
абстрактные типы данных (кластер). Все это нашло отражение в языке Modula-2, где роль 
мониторов выполняли модули с приоритетами (в них реализовывались драйверы устройств), 
а абстрактные типы данных воплощались в понятии скрытых типов (opaque type). Последние 
на уровне описательного модуля (DEFINITION MODULE) выглядели простым названием без 
объявления структуры, а на уровне исполнительного модуля (IMPLEMENTATION MODULE) 
реализовывались, как правило, указателями на комбинированный тип (RECORD). В Обероне 
мониторы, как и другие средства мультипрограммирования Modula-2,  вынесены за пределы 
языка, а абстрактные типы данных реализуются средствами частичного (избирательного) 
экспорта. При этом за счет механизма расширения типа полностью реализуют привычную 
парадигму ООП, но это уже тема другой статьи. #</p></div>



<div align="right"><p><a href="/rb.html">Руслан Богатырев</a>,<br>&nbsp;(19.10.05)</p></div>

  </td>
  <td class="news" valign="top">
  <p><strong>Города:</strong></p>
  <b>O</b>&nbsp;&nbsp;<font color="#6B6B6B">(13 сентября)</font>&nbsp;&nbsp;С.-Петербург 
  <br><b>B</b>&nbsp;&nbsp;<font color="#6B6B6B">(19 сентября)</font>&nbsp;&nbsp;Москва 
  <br><b>E</b>&nbsp;&nbsp;<font color="#6B6B6B">(26 сентября)</font>&nbsp;&nbsp;Нижний Новгород
  <br><b>R</b>&nbsp;&nbsp;<font color="#6B6B6B">(29 сентября)</font>&nbsp;&nbsp;Екатеринбург
  <br><b>O</b>&nbsp;&nbsp;<font color="#6B6B6B">(2 октября)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Новосибирск 
  <br><b>N</b>&nbsp;&nbsp;<font color="#6B6B6B">(5 октября)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Томск 
  
  <br><br>
   <p><strong>Информационные ресурсы:</strong></p>
  <ul>
  <li><a href="http://www.inr.ac.ru/~info21/" target="_blank">Проект 'Информатика-21'</a></li>
  <li><a href="http://www.delphikingdom.ru/" target="_blank">Королевство Delphi</a></li>
  <li><a href="http://www.uni-vologda.ac.ru/oberon/index.html" target="_blank">Оберон. Первый сайт</a></li>
  <li><a href="http://www.delphikingdom.ru/asp/talktopic.asp?ID=285" target="_blank">Форум 'Мысли об Обероне'</a></li>
  <li><a href="http://www.oberon.ethz.ch" target="_blank">ETH Oberon</a></li>
  <li><a href="http://www.modulaware.com/mdltr_.htm" target="_blank">The ModulaTor Journal</a></li>
  <li><a href="http://www.cs.inf.ethz.ch/~wirth/" target="_blank">Niklaus Wirth. Personal Page</a></li>  
  <li><a href="http://en.wikipedia.org/wiki/Niklaus_Wirth" target="_blank">Niklaus Wirth. Wikipedia</a></li>  
  <li><a href="http://www.adeptis.ru/vinci/m_part7_2.html" target="_blank">Niklaus Wirth. Photos</a></li>  
  <li><a href="http://search.barnesandnoble.com/booksearch/results.asp?WRD=Niklaus+Wirth" target="_blank">Niklaus Wirth. Books</a></li>  
  </ul>
  <br>
  <p><strong>Книги Вирта:</strong></p>
  <ul>
  <li><a href="/book/pio2004.pdf">Programming in Oberon (2004)</a></li>
  <li><a href="/book/ads2004.pdf">Algorithms and Data Structures (2004)</a></li>
  <li><a href="/book/po1992.pdf">Project Oberon (1992)</a></li>
  <li><a href="/book/pio1992r.pdf">Oberon. Reiser (1992)</a></li>  
  </ul>
  <br>
  <p><a href="tools.html"><strong>Языки Оберон-семейства:</strong></a></p>
  <ul>
  <li><a href="/paper/oberon.pdf">Oberon (1988-1990)</a></li>
  <li><a href="/paper/oberon-2.pdf">Oberon-2 (1991-1995)</a></li>
  <li><a href="/paper/cp.pdf">Component Pascal (1997-2001)</a></li>
  <li><a href="/paper/act_obe.pdf">Active Oberon (2000-2004)</a></li>  
  <li><a href="/paper/znn.pdf">Zonnon (2003-2005)</a></li>
  </ul>
  <br>
  <p><a href="tools.html"><strong>Инструментарий:</strong></a></p>
  <ul>
  <li><a href="http://www.oberon.ch/blackbox.html" target="_blank">BlackBox [Oberon microsys.]</a></li>
  <li><a href="http://www.inr.ac.ru/~info21/install/welcome.html" target="_blank">BlackBox Russian</a></li>
  <li><a href="http://www.excelsior-usa.com/xds.html" target="_blank">XDS [Excelsior]</a></li>
  <li><a href="http://www.plas.fit.qut.edu.au/gpcp" target="_blank">GPCP JVM/.NET [QUT]</a></li>
  <li><a href="http://www.uni-vologda.ac.ru/~c3c/" target="_blank">JOB [С.Свердлов]</a></li>
  <li><a href="http://ooc.sourceforge.net/" target="_blank">OO2C [sourceforge]</a></li>
  <li><a href="http://www.bluebottle.ethz.ch/" target="_blank">Active Oberon [ETH]</a></li>
  <li><a href="http://www.zonnon.ethz.ch/" target="_blank">Zonnon [ETH]</a></li>
  <li><a href="http://www.zinnamturm.de/" target="_blank">Component Pascal Collection</a></li>
  <li><a href="http://www.modula2.org/" target="_blank">Modula2.org</a></li>
  <li><a href="http://www.modulaware.com/m2wr/?ring=modula2&id=1&m=hub" target="_blank">Modula-2 WebRing</a></li>
  <li><a href="http://v.webring.com/hub?ring=oberon" target="_blank">Oberon-2 WebRing</a></li>
  </ul>
  <br>
  <p><strong>Координаторы турне:</strong></p>
  <ul>
  <li><a href="http://www.osp.ru/pcworld/about/" target="_blank">Р.П.Богатырев (Мир ПК)</a></li>
  <li><a href="http://www.inr.ac.ru/~ftkachov/claims.htm" target="_blank">Ф.В.Ткачев (Институт ядерных исследований РАН)</a></li>
  <li><a href="http://www.inf.ethz.ch/personal/zueff/" target="_blank">Е.А.Зуев (ETH)</a></li>
  <li><a href="http://www.jg.inf.ethz.ch/wiki/JG/Front" target="_blank">Проф. Ю.Гуткнехт (ETH)</a></li>
  <li><a href="http://www.suhomlin.ru/" target="_blank">Проф. В.А.Сухомлин (МГУ)</a></li>
  <li><a href="http://ict.edu.ru/persons/index.php?a=pers&c=getForm&r=persDesc&d=light&id_pers=13" target="_blank">Проф. А.А.Шалыто (ИТМО)</a></li>
  <li><a href="http://www.software.unn.ac.ru/?dir=17" target="_blank">Проф. В.П.Гергель (ННГУ)</a></li>
  </ul>  </td>
 </tr>
</tbody></table></td>
 </tr>
</tbody></table>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
 <tbody><tr>
  <td><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><table border="0" cellpadding="0" cellspacing="0" height="10" width="1"><tbody><tr><td></td></tr></tbody></table></td></tr></tbody></table></td>
 </tr>
</tbody></table>
<p>
</p>

<table border="0" cellpadding="5" cellspacing="0" width="100%">
 <tbody><tr>
  <td class="footer" valign="top" width="80%"><p><b>Организаторы турне:</b> 
  <a href="http://www.pcworld.ru/" target="_blank">Мир ПК</a>, 
  <a href="http://www.inr.ac.ru/~info21/" target="_blank">Информатика-21</a>,
  <a href="http://www.inf.ethz.ch/" target="_blank">ETH Zurich</a>, 
  <a href="http://2005.edu-it.ru/" target="_blank">МГУ</a>, 
  <a href="http://www.ifmo.ru/" target="_blank">ИТМО</a>, 
  <a href="http://www.unn.ru/" target="_blank">ННГУ</a>, 
  <a href="http://www.russoft.ru/index_r.php" target="_blank">РУССОФТ</a>, 
  <a href="http://www.microsoft.com/rus/" target="_blank">Microsoft Russia</a>, 
  <a href="http://www.borland.ru/" target="_blank">Borland</a></p>
</td>
  <td class="footer" align="right" valign="top"><a href="mailto:wirth2005@mail.ru">Контакты</a>
  <p>
  </p>
  </td>
 </tr>
</tbody></table>



</body></html>