/*
;----------------------------------------------------------------;
;                40 New Best Routines (graphic)                  ;
;          (c) SerzhSoft, Shadrinsk, may-june, 1997              ;
;    old length: 1444 bytes         new length:  861 bytes       ;
;----------------------------------------------------------------;
; http://vladik1232008.narod.ru/ZX_FORUM_40_Best_procedures.html ;
;           Adapted to ZXDev/SDCC by Oleg N. Cher, 2012          ;
;----------------------------------------------------------------;
*/

#include "SYSTEM.h"
//#include "Best40.h"

extern SHORTINT Best40_attrib;
#define attrib _Best40_attrib

export void Best40_ASRL_LF (void);
export void Best40_ASRL_RG (void);
export void Best40_ASRL_UP (void);
export void Best40_ASRL_DN (void);
export void Best40_SSRL_LF (void);
export void Best40_SSRL_RG (void);
export void Best40_SSRL_UP (void);
export void Best40_SSRL_DN (void);
export void Best40_PSRL_LF (void);
export void Best40_PSRL_RG (void);
export void Best40_PSRL_UP (void);
export void Best40_PSRL_DN (void);
export void Best40_SCR_MRG (SYSTEM_ADDRESS scr_addr);
export void Best40_SCR_INV (void);
export void Best40_SINV_UD (SYSTEM_ADDRESS char_addr);
export void Best40_SINV_LR (SYSTEM_ADDRESS char_addr);
export void Best40_SROTATE (SYSTEM_ADDRESS char_addr);
export void Best40_ACHANGE (SHORTINT attr_and, SHORTINT attr_or);
export void Best40_AREPLC (SHORTINT attr_from, SHORTINT attr_to);
export void Best40_PAINT (SHORTINT x, SHORTINT y);
export BOOLEAN Best40_POINT (SHORTINT x, SHORTINT y);
export void Best40_PFIGURE (SHORTINT x, SHORTINT y, CHAR *pattern);
export void Best40_PSCALER (
  SHORTINT x1_old, SHORTINT y1_old, SHORTINT x2_old, SHORTINT y2_old,
  SHORTINT xscale, SHORTINT yscale, SHORTINT x_new, SHORTINT y_new);

/*================================== Header ==================================*/

SHORTINT Best40_attrib; // Цвет атрибутов при атрибутных сдвигах

/*--------------------------------- Cut here ---------------------------------*/
/*
;--------------------------------------------------------------;
;Сдвиг атрибутов влево (22<=23)
;--------------------------------------------------------------;
*/
void Best40_ASRL_LF (void)
{
__asm
          LD      DE,#0x5800   // DE=адрес первого байта атрибутов
LP_ASLF$: LD      H,D          // скопировали DE в HL
          LD      L,E          //  и увеличили HL на единицу:
          INC     HL           //  HL=адрес второго байта атрибутов
          LD      BC,#0x001F   // <длина линии атрибутов> - 1
          LDIR                 // сдвиг линии атрибутов влево
          LD      A,(#attrib)  // цвет заполнения после сдвига
          LD      (DE),A       // устанавливаем новый атрибут
          INC     DE           // переход к следующей линии снизу
          LD      A,D          // если атрибуты уже кончились,
          CP      #0x5B        //  и мы набрели на буфер принтера,
          JR      C,LP_ASLF$   //  то STOP, иначе сдвигаем дальше
__endasm;
}//ASRL_LF

/*--------------------------------- Cut here ---------------------------------*/
/*
;--------------------------------------------------------------;
;Сдвиг атрибутов вправо (21<=23)
;--------------------------------------------------------------;
*/
void Best40_ASRL_RG (void)
{
__asm
          LD      DE,#0x5AFF   // адрес последнего байта атрибутов
LP_ASRG$: LD      H,D          // скопировали DE в HL -
          LD      L,E          //  последний байт линии атрибутов
          DEC     HL           // предпоследний байт линии атрибутов
          LD      BC,#0x001F   // <длина линии атрибутов> - 1
          LDDR                 // сдвиг линии атрибутов вправо
          LD      A,(#attrib)  // цвет заполнения после сдвига
          LD      (DE),A       // устанавливаем новый атрибут
          DEC     DE           // переход к следующей линии сверху
          BIT     3,D          // если мы всё ещё в атрибутах,
          JR      NZ,LP_ASRG$  //  то повторяем цикл для сл. линии
__endasm;
}//ASRL_RG

/*--------------------------------- Cut here ---------------------------------*/
/*
;--------------------------------------------------------------;
;Сдвиг атрибутов вверх (19<=21)
;--------------------------------------------------------------;
*/
void Best40_ASRL_UP (void)
{
__asm
          LD      HL,#0x5820   // адрес второй линии атрибутов
          LD      DE,#0x5800   // адрес первой линии атрибутов
          LD      BC,#0x02E0   // перемещать: 23 линии по 32 байта
          LDIR                 // сдвигаем 23 нижние линии вверх
          LD      A,(#attrib)  // цвет для заполнения нижней линии
LP_ASUP$: LD      (DE),A       // устанавливаем новый атрибут
          INC     E            // если заполнили всю последнюю линию
          JR      NZ,LP_ASUP$  //  (E=0), то прерываем цикл
__endasm;
}//ASRL_UP

/*--------------------------------- Cut here ---------------------------------*/
/*
;--------------------------------------------------------------;
;Сдвиг атрибутов вниз (20<=21)
;--------------------------------------------------------------;
*/
void Best40_ASRL_DN (void)
{
__asm
          LD      HL,#0x5ADF   // адрес конца второй линии снизу
          LD      DE,#0x5AFF   // адрес конца самой нижней линии
          LD      BC,#0x02E0   // перемещать: 23 линии по 32 байта
          LDDR                 // сдвигаем 23 верхние линии вниз
          LD      A,(#attrib)  // цвет для заполнения верхней линии
LP_ASDN$: LD      (DE),A       // устанавливаем новый атрибут
          DEC     E            // если дошли до самого первого байта
          JR      NZ,LP_ASDN$  //  области атрибутов (E=0), то STOP
          LD      (DE),A       //  и устанавливаем этот байт
__endasm;
}//ASRL_DN

/*--------------------------------- Cut here ---------------------------------*/
/*
;--------------------------------------------------------------;
;Сдвиг влево на один символ (20<=21)
;--------------------------------------------------------------;
*/
void Best40_SSRL_LF (void)
{
__asm
          LD      DE,#0x4000   // начало области графики
LP_SSLF$: LD      H,D          // адрес первого
          LD      L,E          //  байта линии
          INC     HL           // адрес второго байта линии
          LD      BC,#0x001F   // сколько байт сдвигать
          LDIR                 // сдвиг линии влево на 1 байт
          XOR     A            // обнулили аккумулятор и занесли
          LD      (DE),A       //  в последний (правый) байт линии
          INC     DE           // переход к следующей линии (снизу)
          LD      A,D          // если атрибуты
          CP      #0x58        //  "ещё не видать",
          JR      C,LP_SSLF$   //  то повторяем цикл для сл. линии
__endasm;
}//SSRL_LF

/*
;--------------------------------------------------------------;
;Сдвиг вправо на один символ (19<=22)
;--------------------------------------------------------------;
*/
void Best40_SSRL_RG (void)
{
__asm
          LD      DE,#0x57FF   // последний байт области графики
LP_SSRG$: LD      H,D          // адрес последнего байта
          LD      L,E          //  текущей линии
          DEC     HL           // адрес предпоследнего байта
          LD      BC,#0x001F   // сдвигаем: 31 байт
          LDDR                 // сдвиг линии графики вправо
          XOR     A            // очищаем аккумулятор и затем
          LD      (DE),A       //  первый (левый) байт текущей линии
          DEC     DE           // переход к следующей линии выше
          BIT     6,D          // если мы ещё не "набрели" на ПЗУ,
          JR      NZ,LP_SSRG$  //  то продолжаем крутить цикл
__endasm;
}//SSRL_RG

/*
;--------------------------------------------------------------;
;Сдвиг вверх на один символ (55<=68)
;--------------------------------------------------------------;
*/
void Best40_SSRL_UP (void)
{
__asm
          LD      DE,#0x4000   // начало экранной области
LP_SSU1$: PUSH    DE           // сохраняем адрес линии на стеке
          LD      BC,#0x0020   // в линии - 32 байта
          LD      A,E          // В регистре DE находится адрес
          ADD     A,C          //  верхней линии. В регистре
          LD      L,A          //  HL необходимо получить адрес
          LD      A,D          //  линии, лежащей ниже с шагом 8.
          JR      NC,GO_SSUP$  //  Для этого к регистру E прибав-
          ADD     A,#0x08      //  ляем 32 и заносим в L. Если про-
GO_SSUP$: LD      H,A          //  изошло переполнение, то H=D+8
          LDIR                 // перенос одной линии (32 байта)
          POP     DE           // восстанавливаем адрес начала линии
          LD      A,H          // проверяем: а не пора ли нам закру-
          CP      #0x58        //  гляться? (перенесли все 23 ряда)
          JR      NC,LP_SSU2$  // если да, то переход на очистку
          INC     D            // ---------------------------------;
          LD      A,D          //              DOWN_DE
          AND     #0x07        //  стандартная последовательность
          JR      NZ,LP_SSU1$  //   команд для перехода на линию
          LD      A,E          //      вниз в экранной области
          ADD     A,#0x20      //         (для регистра DE)
          LD      E,A          //
          JR      C,LP_SSU1$   //  на входе:  DE - адрес линии
          LD      A,D          //  на выходе: DE - адрес линии ниже
          SUB     #0x08        //   используется аккумулятор
          LD      D,A          //
          JR      LP_SSU1$     // ---------------------------------;
LP_SSU2$: XOR     A            // очистка аккумулятора
LP_SSU3$: LD      (DE),A       // и с его помощью -
          INC     E            //  очистка одной линии изображения
          JR      NZ,LP_SSU3$  //  всего: 32 байта
          LD      E,#0xE0      // переход к следующей
          INC     D            //  (нижней) линии изображения
          BIT     3,D          // заполнили весь последний ряд?
          JR      Z,LP_SSU2$   // если нет, то продолжаем заполнять
__endasm;
}//SSRL_UP

/*
;--------------------------------------------------------------;
;Сдвиг вниз на один символ (55<=73)
;--------------------------------------------------------------;
*/
void Best40_SSRL_DN (void)
{
__asm
          LD      DE,#0x57FF   // адрес последнего байта графики
LP_SSD1$: PUSH    DE           // сохранили адрес конца линии
          LD      BC,#0x0020   // длина одной линии изображения
          LD      A,E          // в регистре HL
          SUB     C            //  получаем адрес
          LD      L,A          //  конца линии,
          LD      A,D          //  лежащей выше
          JR      NC,GO_SSDN$  //  исходной с шагом
          SUB     #0x08        //  в 8 пикселей (линий):
GO_SSDN$: LD      H,A          //  HL=откуда копировать; DE=куда
          LDDR                 // перенос одной линии графики
          POP     DE           // восстанавливаем адрес конца линии
          BIT     6,H          // если мы уже не в экране,
          JR      Z,LP_SSD2$   //  то переходим на очистку
          LD      A,D          // ---------------------------------;
          DEC     D            //               UP_DE
          AND     #0x07        //  стандартная последовательность
          JR      NZ,LP_SSD1$  //   команд для перехода на линию
          LD      A,E          //     вверх в экранной области
          SUB     #0x20        //         (для регистра DE)
          LD      E,A          //
          JR      C,LP_SSD1$   //  на входе:  DE - адрес линии
          LD      A,D          //  на выходе: DE - адрес линии выше
          ADD     A,#0x08      //   используется аккумулятор
          LD      D,A          //
          JR      LP_SSD1$     // ---------------------------------;
LP_SSD2$: XOR     A            // очистка аккумулятора
LP_SSD3$: LD      (DE),A       // очистка одной
          DEC     E            //  линии изображения:
          JR      NZ,LP_SSD3$  //  (31 байт)
          LD      (DE),A       // очищаем самый первый байт линии
          LD      E,#0x1F      // переход к следующей (верхней)
          DEC     D            //  линии ряда из восьми линий
          BIT     6,D          // мы ещё не попали в ПЗУ?
          JR      NZ,LP_SSD2$  // если нет, то очищаем дальше
__endasm;
}//SSRL_DN

/*
;--------------------------------------------------------------;
;Сдвиг влево на один пиксел (16<=17)
;--------------------------------------------------------------;
*/
void Best40_PSRL_LF (void)
{
__asm
          LD      HL,#0x57FF   // адрес последнего байта графики
LP_PSL1$: OR      A            // сбрасываем флаг переноса CF
          LD      B,#0x20      // в одной линии - 32 байта
LP_PSL2$: RL      (HL)         // CF<-[сдвигаемый байт]<-CF (влево)
          DEC     HL           // переход к предыдущему байту линии
          DJNZ    LP_PSL2$     // цикл сдвига для одной линии
          BIT     6,H          // мы ещё в экране?
          JR      NZ,LP_PSL1$  // если да, то сдвигаем след. линию
__endasm;
}//PSRL_LF

/*
;--------------------------------------------------------------;
;Сдвиг вправо на один пиксел (17)
;--------------------------------------------------------------;
*/
void Best40_PSRL_RG (void)
{
__asm
          LD      HL,#0x4000   // адрес первого байта графики
          LD      C,#0xC0      // сдвигать - 192 линии
LP_PSR1$: OR      A            // CF=0 для пустой колонки слева
          LD      B,#0x20      // число байт в одной линии
LP_PSR2$: RR      (HL)         // сдвиг одного байта вправо
          INC     HL           // следующий байт линии изображения
          DJNZ    LP_PSR2$     // сдвигаем всю линию - 32 байта
          DEC     C            // уменьшаем счетчик линий
          JR      NZ,LP_PSR1$  // если сдвинули все линии, то STOP
__endasm;
}//PSRL_RG

/*
;--------------------------------------------------------------;
;Сдвиг вверх на один пиксел (38<=91)
;--------------------------------------------------------------;
*/
void Best40_PSRL_UP (void)
{
__asm
          LD      DE,#0x4000   // адрес начала графики (верх. линия)
LP_PSU1$: LD      H,D          // скопировали адрес начала
          LD      L,E          //  линии графики в HL
          LD      BC,#0x0020   // размер одной линии
          INC     H            // ---------------------------------;
          LD      A,H          //             DOWN_HL
          AND     #0x07        //  стандартная последовательность
          JR      NZ,GO_PSUP$  //   команд для перехода на линию
          LD      A,L          //      вниз в экранной области
          ADD     A,C          //         (для регистра HL)
          LD      L,A          //  (здесь ADD A,C вместо ADD A,#08)
          JR      C,GO_PSUP$   //  на входе:  HL - адрес линии
          LD      A,H          //  на выходе: HL - адрес линии ниже
          SUB     #0x08        //   используется аккумулятор
          LD      H,A          // ---------------------------------;
GO_PSUP$: PUSH    HL           // сохраняем адрес нижней линии
          LDIR                 // переброска изображения снизу-вверх
          POP     DE           // DE - адрес нижней линии
          LD      A,H          // мы ещё находимся в области графики
          CP      #0x58        //  или уже наткнулись на атрибуты?
          JR      C,LP_PSU1$   // если всё ещё графика, то повтор
          XOR     A            // обнуляем аккумулятор и с его
LP_PSU2$: LD      (DE),A       //  помощью очищаем самую
          INC     E            //  нижнюю линию изображения
          JR      NZ,LP_PSU2$  //  после сдвига экрана вверх
__endasm;
}//PSRL_UP

/*
;--------------------------------------------------------------;
;Сдвиг вниз на один пиксел (38<=90)
;--------------------------------------------------------------;
*/
void Best40_PSRL_DN (void)
{
__asm
          LD      DE,#0x57FF   // адрес последнего байта графики
LP_PSD1$: LD      H,D          // скопировали адрес последнего
          LD      L,E          //  байта линии в HL
          LD      BC,#0x0020   // ширина одной линии изображения
          LD      A,H          // ---------------------------------;
          DEC     H            //               UP_HL
          AND     #0x07        //  стандартная последовательность
          JR      NZ,GO_PSDN$  //   команд для перехода на линию
          LD      A,L          //     вверх в экранной области
          SUB     C            //         (для регистра HL)
          LD      L,A          //    (здесь SUB C вместо SUB #08)
          JR      C,GO_PSDN$   //  на входе:  HL - адрес линии
          LD      A,H          //  на выходе: HL - адрес линии выше
          ADD     A,#0x08      //   используется аккумулятор
          LD      H,A          // ---------------------------------;
GO_PSDN$: PUSH    HL           // сохраняем адрес верхней линии
          LDDR                 // переносим 1 линию сверху - вниз
          POP     DE           // адрес верхней линии стал текущим
          BIT     6,H          // пока ещё не попали в ПЗУ -
          JR      NZ,LP_PSD1$  //  продолжаем цикл по линиям
          XOR     A            // очищаем аккумулятор и с его
LP_PSD2$: LD      (DE),A       //  помощью - самую верхнюю линию
          DEC     E            //  изображения после сдвига
          JR      NZ,LP_PSD2$  //  всего экрана вниз
          LD      (DE),A       // очистка самого первого байта
__endasm;
}//PSRL_DN

/*
;--------------------------------------------------------------;
;Слияние картинок (17<=21)
;--------------------------------------------------------------;
*/
void Best40_SCR_MRG (SYSTEM_ADDRESS scr_addr)
{
__asm
#ifdef __SDCC
          LD      IX,#0xFFFE
          ADD     IX,SP
#endif
          LD      L,4(IX)      // взяли адрес картинки из ячейки
          LD      H,5(IX)
          LD      DE,#0x4000   // адрес экранной области
LP_SCRM$: LD      A,(DE)       // байт изображения с экрана
          OR      (HL)         // "слили" с байтом картинки в памяти
          LD      (DE),A       // и поместили назад в экран
          INC     HL           // следующий байт картинки в памяти
          INC     DE           // следующий байт экранной области
          LD      A,D          // проверка на окончание
          CP      #0x58        //  экранной области
          JR      C,LP_SCRM$   // если не кончилась, то повторяем
__endasm;
}//SCR_MRG

/*
;--------------------------------------------------------------;
;Инвертирование экрана (12<=18)
;--------------------------------------------------------------;
*/
void Best40_SCR_INV (void)
{
__asm
          LD      HL,#0x57FF   // последний байт экранной области
LP_SCRI$: LD      A,(HL)       // взяли байт изображения с экрана
          CPL                  // проинвертировали его
          LD      (HL),A       // и поставили обратно
          DEC     HL           // двигаемся к началу области
          BIT     6,H          // если "перевалили" через начало,
          JR      NZ,LP_SCRI$  //  то STOP, иначе крутим цикл
__endasm;
}//SCR_INV

/*
;--------------------------------------------------------------;
;Инвертирование символа вертикально (20)
;--------------------------------------------------------------;
*/
void Best40_SINV_UD (SYSTEM_ADDRESS char_addr)
{
__asm
#ifdef __SDCC
          LD      IX,#0xFFFE
          ADD     IX,SP
#endif
          LD      L,4(IX)      // взяли из ячейки адрес символа
          LD      H,5(IX)
          LD      D,H          // сохранили этот
          LD      E,L          //  адрес в DE
          LD      B,#0x08      // в символе - 8 байт
LP_SIU1$: LD      A,(HL)       // берём один байт символа
          PUSH    AF           // и заталкиваем на стек
          INC     HL           // переход к следующему байту символа
          DJNZ    LP_SIU1$     // повторяем цикл для восьми байт
          LD      B,#0x08      // сколько байт будем считывать
LP_SIU2$: POP     AF           // извлекаем байт со стека и в обрат-
          LD      (DE),A       //  ном порядке записываем в символ
          INC     DE           // следующий байт символа
          DJNZ    LP_SIU2$     // крутим цикл восемь раз
__endasm;
}//SINV_UD

/*
;--------------------------------------------------------------;
;Инвертирование символа горизонтально (17<=19)
;--------------------------------------------------------------;
*/
void Best40_SINV_LR (SYSTEM_ADDRESS char_addr)
{
__asm
#ifdef __SDCC
          LD      IX,#0xFFFE
          ADD     IX,SP
#endif
          LD      L,4(IX)      // берём из ячейки адрес символа
          LD      H,5(IX)
          LD      B,#0x08      // модифицируем: 8 байт
LP_SIL1$: LD      A,#0x01      // устанавливаем нулевой бит A в 1
LP_SIL2$: RR      (HL)         // вращаем байт символа вправо
          RLA                  // а аккумулятор - влево (через CF)
          JR      NC,LP_SIL2$  // пока нулевой бит не окажется в CF
          LD      (HL),A       // записываем измененный байт
          INC     HL           // следующий байт символа
          DJNZ    LP_SIL1$     // повторяем цикл 8 раз
__endasm;
}//SINV_LR

/*
;--------------------------------------------------------------;
;Вращение символа по часовой стрелке (26<=42)
;--------------------------------------------------------------;
*/
void Best40_SROTATE (SYSTEM_ADDRESS char_addr)
{
__asm
#ifdef __SDCC
          LD      IX,#0xFFFE
          ADD     IX,SP
#endif
          LD      L,4(IX)      // адрес вращаемого символа из ячейки
          LD      H,5(IX)
          LD      B,#0x08      // 8 вертикальных колонок в символе
LP_SRO1$: PUSH    HL           // сохранили адрес на стеке
          LD      A,#0x80      // включили 7-ой бит в аккумуляторе
LP_SRO2$: RR      (HL)         // вращаем байты символа вправо
          RRA                  //  и по одному биту из каждого байта
          INC     HL           //  постепенно заполняем аккумулятор
          JR      NC,LP_SRO2$  //  пока 7 вкл. бит не попадет в CF
          POP     HL           // восстанавливаем адрес символа
          PUSH    AF           // вертик. колонку символа - на стек
          DJNZ    LP_SRO1$     // крутим цикл по числу колонок
          LD      B,#0x08      // колонки стали линиями - байтами
LP_SRO3$: POP     AF           // стаскиваем байт со стека
          LD      (HL),A       // и это - уже новая линия символа
          INC     HL           // следующий байт символа
          DJNZ    LP_SRO3$     // повторяем по числу линий (8 байт)
__endasm;
}//SROTATE

/*
;--------------------------------------------------------------;
;Изменение атрибута (16<=21)
;--------------------------------------------------------------;
*/
void Best40_ACHANGE (SHORTINT attr_and, SHORTINT attr_or)
{
__asm
#ifdef __SDCC
          LD      IX,#0xFFFE
          ADD     IX,SP
#endif
          LD      L,4(IX)      // L - маска битов для операции AND
          LD      H,5(IX)      // H - маска битов для операции OR
          LD      DE,#0x5AFF   // последний байт области атрибутов
LP_ACHN$: LD      A,(DE)       // взяли текущее значение атрибута
          AND     L            // отбросили лишние биты
          OR      H            // добавили необходимые
          LD      (DE),A       // и записали на старое место
          DEC     DE           // движемся к началу атрибутов
          BIT     3,D          // а не графика ли уже?
          JR      NZ,LP_ACHN$  // если нет, то крутим цикл
__endasm;
}//ACHANGE

/*
;--------------------------------------------------------------;
;Смена атрибута (18<=22)
;--------------------------------------------------------------;
*/
void Best40_AREPLC (SHORTINT attr_from, SHORTINT attr_to)
{
__asm
#ifdef __SDCC
          LD      IX,#0xFFFE
          ADD     IX,SP
#endif
          LD      E,4(IX)      // E - что искать
          LD      D,5(IX)      // D - чем заменять
          LD      HL,#0x5AFF   // последний байт области атрибутов
LP_ARPL$: LD      A,(HL)       // взяли байт из области атрибутов
          CP      E            // не тот ли, что ищем?
          JR      NZ,GO_ARPL$  // нет, перепрыгиваем изменение
          LD      (HL),D       // да, изменяем на новое значение
GO_ARPL$: DEC     HL           // движемся к началу обл-ти атрибутов
          BIT     3,H          // атрибуты ещё не кончились?
          JR      NZ,LP_ARPL$  // если нет, то проверяем следующий
__endasm;
}//AREPLC

/*
;--------------------------------------------------------------;
;Закрашивание контура (123<=263)
; 123=88+35 - вместе с процедурой POINT
;--------------------------------------------------------------;
*/
void Best40_PAINT (SHORTINT x, SHORTINT y)
{
__asm
#ifdef __SDCC
          LD      IX,#0xFFFE
          ADD     IX,SP
#else
          POP     AF           // восст. стек для правильного выхода по RET NC/Z
#endif
          LD      L,2(IX)      // координата X начальной точки
          LD      H,3(IX)      // координата Y начальной точки
          LD      A,H          // проверяем координату Y на выход
          CP      #0xC0        //  за пределы экрана:
          RET     NC           //  если Y>=192, то экстренный выход
          SBC     A,A          // т.к. CF=1, то SBC A,A даёт A=#FF -
          PUSH    AF           //  это будет указатель конца стека
          PUSH    HL           // запоминаем координаты первой точки
LP_PNT1$: POP     DE           // берём со стека X,Y след. точки
          INC     D            // если Y=#FF, то стек исчерпан,
          RET     Z            //  и тогда выходим из процедуры
          DEC     D            // восстанавливаем исходн. значение Y
          CALL    POINT$       // проверяем точку с коорд-ми (E,D)
          JR      NZ,LP_PNT1$  // если включена, то переход к след.
          EX      AF,AF        // A'=0, CF=0 - вспомогат. признаки
LP_PNT2$: LD      A,E          // взяли координату X
          OR      A            // если она равна нулю,
          JR      Z,GO_PNT1$   //  то прыжок через движение назад
          DEC     E            // иначе - уменьшаем координату X
          CALL    POINT$       // и проверяем предыдущую точку
          JR      Z,LP_PNT2$   // если "нет препятствия", повторяем
LP_PNT3$: INC     E            // переход на точку вправо (X=X+1)
          JR      Z,LP_PNT1$   // если X>255, то сл. точка со стека
GO_PNT1$: CALL    POINT$       // проверяем следующую правую точку
          JR      NZ,LP_PNT1$  // если включена, то след. со стека
          LD      A,(HL)       // если точка не установлена,
          OR      C            //  то берём байт с экрана, включаем
          LD      (HL),A       //  нужный бит и ставим назад
          LD      A,D          // проверяем координату Y:
          OR      A            // если она равна нулю,
          JR      Z,GO_PNT4$   //  то не проверяем лежащ. выше линию
          DEC     D            // переход к линии выше (Y=Y-1)
          CALL    POINT$       // проверка вышележащей точки
          JR      Z,GO_PNT2$   // если не включена, то переход
          EX      AF,AF        // взяли вспомогательные флаги
          LD      A,B          // разрешили запоминать точку в стеке
          JR      GO_PNT3$     // переход на продолжение
GO_PNT2$: EX      AF,AF        // взяли вспомогательные флаги
          INC     A            // если A>0, то это означает запрет
          DEC     A            //  на сохранение координаты новой
          JR      NZ,GO_PNT3$  //  точки в стеке, -> перепрыгиваем
          LD      A,C          // иначе - запрещаем сохранять коор-
          PUSH    DE           //  динаты, но одну пихаем на стек
GO_PNT3$: EX      AF,AF        // сохранили вспомогательные флаги
          INC     D            // возвращаемся на нижнюю линию
GO_PNT4$: LD      A,D          // проверяем координату Y:
          CP      #0xBF        // если - последняя (ниже не бывает),
          JR      NC,LP_PNT3$  //  то переход к след. точке справа
          INC     D            // иначе - спускаемся на линию ниже
          CALL    POINT$       // проверяем нижележащую точку
          JR      Z,GO_PNT5$   // если не включена, то переход
          EX      AF,AF        // взяли вспомогательные флаги
          AND     A            // разрешили запоминать точку в стеке
          JR      GO_PNT6$     // переход на продолжение
GO_PNT5$: EX      AF,AF        // взяли вспомогательные флаги
          JR      C,GO_PNT6$   // если нельзя сохранять, то переход
          SCF                  // запрещаем сохранять точку на стеке
          PUSH    DE           // но одну точку на стек запихиваем
GO_PNT6$: EX      AF,AF        // сохранили вспомогательные флаги
          DEC     D            // возвращаемся на верхнюю линию
          JR      LP_PNT3$     // переход к следующей точке справа
__endasm;
}//PAINT

/*
;--------------------------------------------------------------;
;Проверка состояния точки и вычисление адреса в экране (35<=70)
;--------------------------------------------------------------;
*/
BOOLEAN Best40_POINT (SHORTINT x, SHORTINT y)
{
__asm
#ifdef __SDCC
          LD      IX,#0xFFFE
          ADD     IX,SP
#else
          POP     AF           // восст. стек для правильного выхода по RET
#endif
          LD      E,4(IX)      // координата X
          LD      D,5(IX)      // координата Y
          CALL    POINT$       // вызов POINT
          LD      L,A          // результат: 0 (FALSE) или не 0 (TRUE)
          RET
POINT$:   // если точка выключена, то ZF=1 (Z), иначе ZF=0 (NZ)
          LD      B,#0x07      // часто используемая маска (#07)
          LD      A,D          // взяли Y-координату
          RRA                  // разделили её на 8
          SCF                  //  и начали формировать
          RRA                  //  старший байт
          RRA                  //  адреса пиксела
          AND     #0x5F        //  в экране (регистр H):
          LD      H,A          //   %010yyyyy
          XOR     E            // далее формируем
          AND     B            //  младший байт
          XOR     E            //  адреса
          RRCA                 //  пиксела
          RRCA                 //  в экране
          RRCA                 //  (регистр L):
          LD      L,A          //   %yyyxxxxx
          LD      A,D          // заканчиваем
          XOR     H            //  формирование
          AND     B            //  старшего байта
          XOR     H            //  адреса пиксела
          LD      H,A          //  в экране (регистр H)
          LD      A,E          // начинаем формировать
          AND     B            //  маску пиксела в байте
          LD      B,A          //  изображения (соответствующий
          LD      A,#0x80      //  бит включен). Включаем 7-ой бит
          JR      Z,GO_PNT$    // если это как раз то что надо,
LP_PNT$:  RRCA                 //  то перепрыгиваем через сдвиг
          DJNZ    LP_PNT$      //  включенного бита вправо
GO_PNT$:  LD      C,A          // сохраняем маску вкл. бита в рег. C
          AND     (HL)         // проверяем пиксел в экране
__endasm;
}//POINT

/*
;--------------------------------------------------------------;
;Построение шаблонов (98<=196)
; 98+35=133 - вместе с процедурой POINT
;--------------------------------------------------------------;
*/
void Best40_PFIGURE_E (SHORTINT x, SHORTINT y, CHAR *pattern)
{
__asm
#ifdef __SDCC
          LD      IX,#0xFFFE
          ADD     IX,SP
#else
          POP     AF           // восст. стек для правильного выхода по RET Z
#endif
          LD      E,4(IX)      // координата X начальной точки
          LD      D,5(IX)      // координата Y начальной точки
          LD      L,6(IX)      // адрес шаблона pattern в памяти
          LD      H,7(IX)
          DEC     HL           // первый раз адрес остаётся неизменным
LP_PFG3$: INC     HL           //  потом будем прибавлять, переходя к след.симв.
          LD      A,(HL)       // взяли очередной символ данных шаблона
          OR      A            // если достигнут конец (символ с кодом 0)
          RET     Z            //  выходим из процедуры
          CP      #"0"         // а не "поставить ли точку"?
          JR      NZ,GO_PFG6$  // если нет, переход на продолжение
          LD      A,D          // y-координата текущей точки
          CP      #0xC0        // если выходит за нижнюю кромку
          JR      NC,LP_PFG3$  //  экрана, то точку не изображаем
          PUSH    HL           // иначе - сохраняем некоторые
          PUSH    BC           //  регистры, чтоб не портились
          CALL    POINT$       // вызываем процедуру проверки точки
          LD      A,(HL)       // по вычисленным значениям
          OR      C            //  изображаем точку на экране
          LD      (HL),A       //  пользуясь тем, что HL=адрес,
          POP     BC           //  а регистр C содержит маску точки
          POP     HL           // восстанавливаем сохр-ные регистры
          JR      LP_PFG3$     // обработка след. символа шаблона
GO_PFG6$: SUB     #"5"         // сместить перо влево?
          JR      NZ,GO_PFG7$  // если нет, то оставить всё как есть
          DEC     E            // иначе - уменьшить x-координату
GO_PFG7$: DEC     A            // двигаемся вниз?
          JR      NZ,GO_PFG8$  // нет, переход
          INC     D            // да, увеличиваем y-координату
GO_PFG8$: DEC     A            // направление "вверх"?
          JR      NZ,GO_PFG9$  // нет, перепрыгиваем
          DEC     D            // да, уменьшаем y-координату
GO_PFG9$: DEC     A            // может надо сдвинуться вправо?
          JR      NZ,LP_PFG3$  // нет, переход к след. символу шабл.
          INC     E            // да, увеличиваем x-координату
          JR      LP_PFG3$     //  и переходим к след. символу шабл.
__endasm;
}//PFIGURE_E

/*
;--------------------------------------------------------------;
;Увеличение экрана и копирование (174<=335)
; 174+35=209 - вместе с процедурой POINT
;--------------------------------------------------------------;
*/
void Best40_PSCALER (
  SHORTINT x1_old, SHORTINT y1_old, SHORTINT x2_old, SHORTINT y2_old,
  SHORTINT xscale, SHORTINT yscale, SHORTINT x_new, SHORTINT y_new)
{
__asm
          LD      L,6(IX)      // xscale
          LD      H,7(IX)      // yscale
/*
          LD      HL,(CONSTS+4);масштабность увеличения по x и y
          INC     L            ;проверка x-координаты
          DEC     L            ; на нулевое значение
          RET     Z            ;если равна 0, то ошибка (выход)
          INC     H            ;проверка y-координаты
          DEC     H            ; на нулевое значение
          RET     Z            ;если равна 0, то ошибка (выход)
          LD      HL,(CONSTS+6);новые x-,y-координаты ("куда")
          LD      A,#BF        ;максимально возможная y-координата
          CP      H            ;проверяем новую y-координату
          RET     C            ;если не в экране - выход
          LD      HL,(CONSTS)  ;x1-,y1-координаты ("откуда")
          CP      H            ;проверяем y1 на вхождение в экран
          RET     C            ;если за экраном, то выходим
          LD      DE,(CONSTS+2);x2-,y2-координаты ("откуда")
          CP      D            ;y2 находится в экране?
          RET     C            ;если нет, то выход из процедуры
          LD      A,E          ;координата x2
          CP      L            ;сравнили с координатой x1
          JR      NC,GO_PSC1   ;если L больше E, то всё нормально
          EX      DE,HL        ;иначе - поменяли их местами
GO_PSC1$: LD      A,D          ;координата y2
          CP      H            ;сравнили с координатой y1
          JR      NC,GO_PSC2   ;если H больше D, то перепрыгиваем
          LD      D,H          ;иначе - меняем
          LD      H,A          ; их местами
GO_PSC2$: LD      A,D          ;большая из y-координат
          SUB     H            ;вычитаем меньшую y-координату
          INC     A            ;и прибавляем 1
          EXX                  ;перешли к альтернативным регистрам
          LD      B,A          ;величина смещения по y (высота)
          EXX                  ;вернулись к основным регистрам
          LD      A,E          ;большая из x-координат
          SUB     L            ;вычитаем меньшую x-координату
          INC     A            ;прибавили единичку
          EXX                  ;сменили набор регистров
          LD      C,A          ;величина смещения по x (ширина)
          EXX                  ;вернулись к осн. набору регистров
          PUSH    AF           ;закинули один байт на стек (любой)
          INC     SP           ; - это необходимо для завершения
          LD      C,#08        ;число бит в одном байте
LP_PSC1$: LD      A,E          ;запоминаем в альтернативном акку-
          EX      AF,AF        ; муляторе коорд. x окончания линии
LP_PSC2$: PUSH    HL           ;запоминаем регистры HL,BC на стеке
          PUSH    BC           ; чтобы не испортились
          CALL    POINT        ;вызов процедуры проверки точки
          POP     BC           ;восстанавливаем сохраненные
          POP     HL           ; регистры BC,HL со стека
          ADD     A,#FF        ;если A>0, то флаг CF включится
          RR      B            ;"вкручиваем" этот бит в регистр B
          DEC     C            ;уменьшаем счетчик количества битов
          JR      NZ,GO_PSC3   ;если не ноль, то перепрыгиваем
          PUSH    BC           ;иначе - забрасываем на стек
          INC     SP           ; регистр B (только 1 байт)
          LD      C,#08        ; и устанавливаем счетчик битов
GO_PSC3$: LD      A,E          ;текущая x-координата
          DEC     E            ;движемся по линии влево
          CP      L            ;проверка на окончание линии
          JR      NZ,LP_PSC2   ;крутим цикл по линии
          EX      AF,AF'       ;восстанавливаем значение
          LD      E,A          ; x-координаты из альтернативного A
          LD      A,D          ;текущая y-координата
          DEC     D            ;движемся по строчкам вверх
          CP      H            ;это была последняя линия?
          JR      NZ,LP_PSC1   ;если нет, то крутим цикл по линиям
          LD      A,#08        ;число битов в байте
          SUB     C            ;A=число заполненных битов в рег. B
          JR      NZ,GO_PSC4   ;если не ноль, то перепрыгиваем
          LD      A,C          ;A=C=8 - число бит в байте
          DEC     SP           ;снимаем со стека последний
          POP     BC           ; заброшенный туда байт
GO_PSC4$: LD      C,A          ;сколько битов данных в посл. байте
          LD      DE,(CONSTS+6);новые x-,y-координаты ("куда")
LP_PSC3$: LD      A,E          ;сохраняем x-координату начала
          EX      AF,AF        ; линии изображения в A'
          EXX                  ;переход к альтернативным регистрам
          LD      E,C          ;это будет счетчик точек по x
LP_PSC4$: EXX                  ;вернулись к осн. набору регистров
          EX      AF,AF        ;переход к альтерн. флаг. регистру
          RLC     B            ;флаг CF - выводить/не_выв. точку
          EX      AF,AF        ;вернулись к нормальным флагам
          PUSH    BC           ;сохраняем байт данных и сч. битов
          LD      HL,(CONSTS+4);масштабность увеличения по x и y
          LD      B,H          ;сохранили масштабы увеличения
          LD      C,L          ; в регистрах C и B (x и y)
          PUSH    DE           ;сохраняем коор-ты (цикл по линиям)
LP_PSC5$: PUSH    DE           ;сохраняем коор-ты (цикл по точкам)
LP_PSC6$: PUSH    HL           ;сохраняем регистры HL и BC
          PUSH    BC           ; перед вызовом процедуры POINT
          CALL    POINT        ;расчет адреса в экране и маски
          LD      A,C          ;маска точки (бит включен)
          POP     BC           ;восстановили BC со стека
          EX      AF,AF'       ;проверяем альтернативный флаг CF
          JR      C,GO_PSC5    ;если он включен, то перепрыгиваем
          EX      AF,AF'       ;сохраняем этот флаг CF
          CPL                  ;инвертируем маску бита точки
          AND     (HL)         ; и с её помощью сбрасываем пиксел
          JR      GO_PSC6      ;переход на продолжение
GO_PSC5$: EX      AF,AF'       ;флаг CF делаем снова альтерн-ным
          OR      (HL)         ;включаем пиксел
GO_PSC6$: LD      (HL),A       ;запись измененного байта в экран
          POP     HL           ;восстанавливаем HL (сч. масштаба)
          INC     E            ;переход к сл. точке в линии экрана
          DEC     L            ;уменьшаем счетчик масштаба по x
          JR      NZ,LP_PSC6   ;пока не ноль, продолжаем цикл
          LD      L,C          ;восстанавливаем значение x-масшт.
          POP     DE           ;восстан-ем координаты начала линии
          INC     D            ;переход к следующей линии в экране
          DEC     H            ;уменьшаем счетчик масштаба по y
          JR      NZ,LP_PSC5   ;и крутимся, пока он не достигнет 0
          LD      H,B          ;восстанавливаем значение y-масшт.
          POP     DE           ;восстан-ем координаты начала точки
          LD      A,E          ;переход к началу следующего
          ADD     A,L          ; прямоугольника, изображающего
          LD      E,A          ; одну точку изображения (вправо)
          POP     BC           ;восстанавливаем байт д-х и счетчик
          DEC     C            ;уменьшаем счетчик битов в байте B
          JR      NZ,GO_PSC7   ;если есть ещё биты, то переход
          DEC     SP           ;иначе - считываем со стека
          POP     BC           ; следующий байт данных в регистр B
          LD      C,#08        ;устанавливаем счетчик битов
GO_PSC7$: EXX                  ;переход к альтернативным регистрам
          DEC     E            ;уменьшаем счетчик точек в строчке
          JR      NZ,LP_PSC4   ;если ещё есть точки, то крутимся
          EXX                  ;вернулись к осн. набору регистров
          EX      AF,AF'       ;восстанавливаем из альтернативного
          LD      E,A          ; аккумулятора x-координату строчки
          LD      A,D          ;переход к началу следующего прямо-
          ADD     A,H          ; угольника, изображающего одну
          LD      D,A          ; точку изображения (вниз)
          EXX                  ;переход к альтернативным регистрам
          DEC     B            ;уменьшаем счетчик строк спрайта
          EXX                  ;вернулись к осн. набору регистров
          JR      NZ,LP_PSC3   ;цикл, если строчки не закончились
*/
__endasm;
}//PSCALER

/*
;--------------------------------------------------------------;
; end of         40 New Best Routines (graphic)                ;
;--------------------------------------------------------------;

Сохранение: SAVE "nbestg.c" CODE 62000,861

           *   *   *
*/
